(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[530],{4530:(e,t,a)=>{"use strict";a.r(t),a.d(t,{NonLinearDataModule:()=>Z});var i=a(8583),n=a(2389),r=a(1077);const s={defination:r.W.setHeader("A graph is a non-linear kind of data structure made up of nodes or vertices and edges. The edges connect any two nodes in the graph, and the nodes are also known as vertices"),properties:r.W.setListwithTitleHtml("Properties",["<b>Adjacency Matrix</b>: The adjacency matrix of a simple labeled graph, also known as the connection matrix, is a matrix with rows and columns labeled by graph vertices and a 1 or 0 in position depending on whether they are adjacent or not","<b>Adjacency List</b>: A finite graph is represented by an adjacency list, which is a collection of unordered lists. Each unordered list describes the set of neighbors of a particular vertex in the graph within an adjacency list"]),example:r.W.setExampleImage("Example","assets/ds-image/graph.jpg"),operations:r.W.setListwithTitleHtml("Operations",["Creating graphs","Insert vertex","Delete vertex","Insert edge","Delete edge"]),advantage:r.W.setListwithTitleHtml("Advantages",["By using graphs we can easily find the shortest path, neighbors of the nodes, and many more","Graphs are used to implement algorithms like DFS and BFS","It is used to find minimum spanning tree which has many practical applications","It helps in organizing data","Because of its non-linear structure, helps in understanding complex problems and their visualization"]),disadvantage:r.W.setListwithTitleHtml("Disadvantages",["Graphs use lots of pointers which can be complex to handle","It can have large memory complexity","If the graph is represented with an adjacency matrix then it does not allow parallel edges and multiplication of the graph is also difficult"]),applications:r.W.setListwithTitleHtml("Applications",["Graphs are used to represent flow of control in computers","Graphs are used in social networking sites where users act as nodes and connection between them acts as edges","In an operating system, graphs are used as resource allocation graphs","Graphs are used in Google maps to find the shortest route","Graphs are also used in airlines system for effective route optimization","In-state transition diagrams, the graph is used to represent their states and their transition","In transportation, graphs are used to find the shortest path","In circuits, graphs can be used to represent circuit points as nodes and wires as edges","Graphs are used in solving puzzles with only one solution, such as mazes","Graphs are used in computer networks for Peer to peer (P2P) applications","Graphs basically in the form of DAG(Directed acyclic graph) are used as alternative to blockchain for cryptocurrency. For example crypto like  IOTA, Nano are mainly based on DAG"]),terminologies:r.W.setListwithTitleHtml("Terminologies",["An edge is one of the two primary units used to form graphs. Each edge has two ends, which are vertices to which it is attached","If two vertices are endpoints of the same edge, they are adjacent","A vertex's outgoing edges are directed edges that point to the origin","A vertex's incoming edges are directed edges that point to the vertex's destination","The total number of edges occurring to a vertex in a graph is its degree","The out-degree of a vertex in a directed graph is the total number of outgoing edges, whereas the in-degree is the total number of incoming edges","A vertex with an in-degree of zero is referred to as a source vertex, while one with an out-degree of zero is known as sink vertex","An isolated vertex is a zero-degree vertex that is not an edge's endpoint","A path is a set of alternating vertices and edges, with each vertex connected by an edge","The path that starts and finishes at the same vertex is known as a cycle","A path with unique vertices is called a simple path","For each pair of vertices x, y, a graph is strongly connected if it contains a directed path from x to y and a directed path from y to x","A directed graph is weakly connected if all of its directed edges are replaced with undirected edges, resulting in a connected graph. A weakly linked graph's vertices have at least one out-degree or in-degree","A tree is a connected forest. The primary form of the tree is called a rooted tree, which is a free tree","A spanning subgraph that is also a tree is known as a spanning tree","A connected component is the unconnected graph's most connected subgraph","A bridge, which is an edge of removal, would sever the graph","Forest is a graph without a cycle"]),type:r.W.setListwithTitleHtml("Type",["<b>Finite Graph</b>: The graph G=(V, E) is called a finite graph if the number of vertices and edges in the graph is limited in number","<b>Infinite Graph</b>: The graph G=(V, E) is called a finite graph if the number of vertices and edges in the graph is interminable","<b>Trivial Graph</b>:A graph G= (V, E) is trivial if it contains only a single vertex and no edges","<b>Simple Graph</b>:If each pair of nodes or vertices in a graph G=(V, E) has only one edge, it is a simple graph. As a result, there is just one edge linking two vertices, depicting one-to-one interactions between two elements","<b>Multi Graph</b>:If there are numerous edges between a pair of vertices in a graph G= (V, E), the graph is referred to as a multigraph. There are no self-loops in a Multigraph","<b>Null Graph</b>:It's a reworked version of a trivial graph. If several vertices but no edges connect them, a graph G= (V, E) is a null graph","<b>Complete Graph</b>: If a graph G= (V, E) is also a simple graph, it is complete. Using the edges, with n number of vertices must be connected. It's also known as a full graph because each vertex's degree must be n-1","<b>Pseudo Graph</b>: If a graph G= (V, E) contains a self-loop besides other edges, it is a pseudograph","<b>Regular Graph</b>:If a graph G= (V, E) is a simple graph with the same degree at each vertex, it is a regular graph. As a result, every whole graph is a regular graph","<b>Weighted Graph</b>: A graph G= (V, E) is called a labeled or weighted graph because each edge has a value or weight representing the cost of traversing that edge","<b>Directed Graph</b>: A directed graph also referred to as a digraph, is a set of nodes connected by edges, each with a direction","<b>Undirected Graph</b>:An undirected graph comprises a set of nodes and links connecting them. The order of the two connected vertices is irrelevant and has no direction. You can form an undirected graph with a finite number of vertices and edges","<b>Connected Graph</b>:If there is a path between one vertex of a graph data structure and any other vertex, the graph is connected","<b>Disconnected Graph</b>: When there is no edge linking the vertices, you refer to the null graph as a disconnected graph","<b>Cyclic Graph</b>:If a graph contains at least one graph cycle, it is considered to be cyclic","<b>Acyclic Graph</b>:When there are no cycles in a graph, it is called an acyclic graph","<b>Directed Acyclic Graph</b>:It's also known as a directed acyclic graph (DAG), and it's a graph with directed edges but no cycle. It represents the edges using an ordered pair of vertices since it directs the vertices and stores some data","<b>Subgraph</b>:The vertices and edges of a graph that are subsets of another graph are known as a subgraph"])};var o=a(3018);let h=(()=>{class e{constructor(e){this.location=e,this.graphMetaData=s}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-graph"]],decls:15,vars:9,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Graph"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4),o._UZ(13,"div",4),o._UZ(14,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.graphMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.terminologies,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.type,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.graphMetaData.disadvantage,o.oJD))},styles:[""]}),e})();const l={defination:r.W.setHeader("A <b>hash table</b> is a type of data structure that stores key-value pairs. The key is sent to a hash function that performs arithmetic operations on it. The result (commonly called the hash value or hash) is the index of the key-value pair in the hash table.<br>Hashing is a technique which uses less key comparisons and searches the element in O(n) time in the worst case and in an average case it will be done in O(1) time"),properties:r.W.setListwithTitleHtml("Hash Funtion Properties",["The hash function is easy to understand and simple to compute","The hash function should produce the keys which will get distributed, uniformly over an array","A number of collisions should be less while placing the data in the hash table","The hash function is a perfect hash function when it uses all the input data"]),type:r.W.setListwithTitleHtml("Hash Funtion Types",["<b> Division method</b>: In this the hash function is dependent upon the remainder of a division. For example:-if the record 52,68,99,84 is to be placed in a hash table and let us take the table size is 10.<br> h(key)=record% table size.","<b>Mid square method</b>: In this method firstly key is squared and then mid part of the result is taken as the index. For example: consider that if we want to place a record of 3101 and the size of table is 1000. So 3101*3101=9616201 i.e. h (3101) = 162 (middle 3 digit)","<b>Digit folding method</b>: In this method the key is divided into separate parts and by using some simple operations these parts are combined to produce a hash key. For example: consider a record of 12465512 then it will be divided into parts i.e. 124, 655, 12. After dividing the parts combine these parts by adding it.<br>H(key)=124+655+12"]),example:r.W.setExampleImage("Example","assets/ds-image/hash-table.jpg"),operations:r.W.setListwithTitleHtml("Operations",["<b>Search</b>: Searches an element in a hash table","<b>Insert</b>: inserts an element in a hash table","<b>delete</b>: Deletes an element from a hash table"]),terminologies:r.W.setListwithTitleHtml("Components of a hash table",["<b>Hash function</b>: As we\u2019ve already seen, the hash function determines the index of our key-value pair. Choosing an efficient hash function is a crucial part of creating a good hash table. You should always ensure that it\u2019s a one-way function, i.e., the key cannot be retrieved from the hash. Another property of a good hash function is that it avoids producing the same hash for different keys","<b>Array</b>: The array holds all the key-value entries in the table. The size of the array should be set according to the amount of data expected"]),other:r.W.setListwithTitleHtml("Collision resolution technique",["If there is a problem of collision occurs then it can be handled by apply some technique. These techniques are called as collision resolution techniques","<b>Chaining</b>:It is a method in which additional field with data i.e. chain is introduced. A chain is maintained at the home bucket. In this when a collision occurs then a linked list is maintained for colliding data","<b>Linear probing</b>:It is very easy and simple method to resolve or to handle the collision. In this collision can be solved by placing the second record linearly down, whenever the empty place is found. In this method there is a problem of clustering which means at some place block of a data is formed in a hash table","<b>Quadratic probing</b>:This is a method in which solving of clustering problem is done. In this method the hash function is defined by the H(key)=(H(key)+x*x)%table size. Let us consider we have to insert following elements that are:-67, 90,55,17,49","<b>Double hashing</b>: It is a technique in which two hash function are used when there is an occurrence of collision. In this method 1 hash function is simple as same as division method. But for the second hash function there are two important rules which are <br>1.It must never evaluate to zero.<br> 2.Must sure about the buckets, that they are probed"]),advantage:r.W.setListwithTitleHtml("Advantages",["Hash provides better synchronization than other data structures","Hash tables are more efficient than search trees or other data structures","Hash provides constant time for searching, insertion and deletion operations on average"]),disadvantage:r.W.setListwithTitleHtml("Disadvantages",["Hash is inefficient when there are many collisions","Hash collisions are practically not be avoided for large set of possible keys","Hash does not allow null values"]),applications:r.W.setListwithTitleHtml("Applications",["Hash is used in databases for indexing","Hash is used in disk based data structures","In some programming languages like Python, JavaScript hash is used to implement objects","Hash is used for cache mapping for fast access of the data","Hash can be used for password verification","Hash is used in cryptography as a message digest","P1:Check if two arrays are equal or not","P2:The intersection of two unsorted array","P3:Longest Consecutive Sequence","P4:Valid Anagram","P5:Majority Element","P6:Sort characters by frequency","P7:Triplet with 0 sum","P8:First missing positive","P9:Largest subarray with 0 sum","P10:Max points on the straight line"])};let d=(()=>{class e{constructor(e){this.location=e,this.hashTableMetaData=l}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-hash-table"]],decls:16,vars:10,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Hash Table"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4),o._UZ(13,"div",4),o._UZ(14,"div",4),o._UZ(15,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.hashTableMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.terminologies,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.type,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.other,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.hashTableMetaData.disadvantage,o.oJD))},styles:[""]}),e})();const c=["Binary Tree","Binary Search Tree","AVL Tree","Heap Tree"],p={defination:r.W.setHeader("A tree is a non-linear type of data structure that organizes data hierarchically. It consists of nodes connected by edges. Each node contains a value and may or may not have a child node"),properties:r.W.setListwithTitleHtml("Properties",["<b>Number of edges</b>: An edge can be defined as the connection between two nodes. If a tree has N nodes then it will have (N-1) edges. There is only one path from each node to any other node of the tree","<b>Depth of a node</b>: The depth of a node is defined as the length of the path from the root to that node. Each edge adds 1 unit of length to the path. So, it can also be defined as the number of edges in the path from the root of the tree to the node","<b>Height of a node</b>: The height of a node can be defined as the length of the longest path from the node to a leaf node of the tree","<b>Height of the tree</b>: The height of a tree is the length of the longest path from the root of the tree to a leaf node of the tree","<b>Degree of a Node</b>: The total count of subtrees attached to that node is called the degree of the node. The degree of a leaf node must be 0. The degree of a tree is the maximum degree of a node among all the nodes in the tree","Traversing in a tree is done by depth first search and breadth first search algorithm","It has no loop and no circuit","It has no self-loop","Its hierarchical model"]),terminologies:r.W.setListwithTitleHtml("Terminologies",["<b>Node</b>: Node is the main component of a tree that stores the data along with the links to other nodes","<b>Edge</b>: Edge( also called branch) connects two nodes of a tree. A node can have more than one edge","<b>Parent</b>: Parent node is a predecessor to any other node. In simple words, it is a node in the tree that has branches to other nodes","<b>Child</b>: The node which is connected below to another node is called a child of that node. All nodes except the root node are child nodes","<b>Root</b>: The first node of the tree which originates it is called the root of the tree. A tree can have only one root","<b>Leaf node(External node)</b>: Nodes with no child are called leaf nodes or external nodes","<b>Internal node(Non-Leaf node)</b>: Nodes with at least one child is called an internal node or non-leaf nodes","<b>Siblings</b>: Nodes having the same parent are called siblings","<b>Cousins</b>: The nodes belonging to the same level with different parent nodes","<b>Degree</b>:Degree of a node is defined as the number of children of that node. The degree of the tree is the highest degree of a node among all the nodes","<b>Path</b>: The nodes in the tree has to be reachable from other nodes through a unique sequence of edges called path. The number of edges in a path is called the length of the path","<b>Level of a node</b>: The level of a node is defined as the number of edges in the unique path between the root and the node","<b>Subtree</b>: A tree formed by a node and all of its descendants in the tree is called a subtree"]),example:r.W.setExampleImage("Example","assets/ds-image/tree.jpg"),operations:"",type:r.W.setListwithTitleHtml("Type of tree",c),applications:r.W.setListwithTitleHtml("Applications",["Trees can be used to store data which are in hierarchical form","Different types of trees are used in various fields like in databases, computer graphics, computer networks","Tree data structure are used by operating system to manage file directory","Databases use tree data structure for indexing","Tree data structure is used in file directory management","DNS uses tree data structure","Trees are used in several games like moves in chess","Decision based algorithms in machine learning uses tree algorithms"]),advantage:r.W.setListwithTitleHtml("Advantage",["Trees provide hierarchical representation for the data","Trees are dynamic in nature so the number of nodes are not limited","Insertion and deletion in a tree can be done in moderate time"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["Some trees can only be stored using sequential or chained storage"])},m=[{type:c[0],url:"/non-primitive/non-linear/binary-tree"},{type:c[1],url:"/non-primitive/non-linear/binary-search-tree"},{type:c[2],url:"/non-primitive/non-linear/avl-tree"},{type:c[3],url:"/non-primitive/non-linear/heap-tree"}],g={defination:r.W.setHeader("A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child."),properties:r.W.setListwithTitleHtml("Properties",["The maximum number of nodes at level \u2018l\u2019 of a binary tree is 2l","The Maximum number of nodes in a binary tree of height \u2018h\u2019 is 2h \u2013 1","In a Binary Tree with N nodes, minimum possible height or the minimum number of levels is Log2(N+1)","A Binary Tree with L leaves has at least | Log2L |+ 1   levels"," In Binary tree where every node has 0 or 2 children, the number of leaf nodes is always one more than nodes with two children","In a non empty binary tree, if n is the total number of nodes and e is the total number of edges, then e = n-1"]),example:r.W.setExampleImage("Example","assets/ds-image/binary-tree.jpg"),operations:"",advantage:r.W.setListwithTitleHtml("Advantage",["The searching operation in a binary tree is very fast","The representation of a binary tree is simple and easy to understand","Traversing from a parent node to its child node and vice-versa is efficiently done","Simple to implement","Easy to understand","Reflect structural relationships that are present in the data set","Executions are fast","Store an arbitrary number of data values"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["In binary tree traversals, there are many pointers that are null and hence useless","The access operation in a Binary Search Tree (BST) is slower than in an array","A basic option is dependent on the height of the tree","Deletion node not easy","A basic option is based on the height of tree"]),applications:r.W.setListwithTitleHtml("Applications",["Huffman coding tree is an application of binary trees that are used in data compression algorithms","In compilers, Expression Trees are used which are applications of binary trees","Priority Queue is another application of binary tree that is used to search maximum or minimum in O(log N) time complexity","Represent hierarchical data","Used in editing software like Microsoft Excel and spreadsheets","Useful for indexing segmented at the database is useful in storing cache in the system","Syntax trees are used for most famous compilers for programming like GCC, and AOCL to perform arithmetic operations","For implementing priority queues","Used to find elements in less time (binary search tree)","Used to enable fast memory allocation in computers","To perform encoding and decoding operations","DOM in HTML","File explorer","Used as the basic data structure in Microsoft Excel and spreadsheets","Routing Algorithms","Evaluate an expression"]),type:r.W.setListwithTitleHtml("Types of binary tree",["<b>Full Binary Tree</b>: A Binary Tree is a full binary tree if every node has 0 or 2 children. The following are the examples of a full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaf nodes have two children. It is also known as a proper binary tree","<b>Complete Binary Tree</b>: A Binary Tree is a Complete Binary Tree if all the levels are completely filled except possibly the last level and the last level has all keys as left as possible.A complete binary tree is just like a full binary tree, but with two major differences.(I)Every level must be completely filled. (II)All the leaf elements must lean towards the left","<b>Perfect Binary Tree</b>: A Binary tree is a Perfect Binary Tree in which all the internal nodes have two children and all leaf nodes are at the same level","<b>Balanced Binary Tree</b>: A binary tree is balanced if the height of the tree is O(Log n) where n is the number of nodes. For Example, the AVL tree maintains O(Log n) height by making sure that the difference between the heights of the left and right subtrees is at most 1. Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths is the same and there are no adjacent red nodes. Balanced Binary Search trees are performance-wise good as they provide O(log n) time for search, insert and delete","<b>A degenerate (or pathological) tree</b>: A Tree where every internal node has one child. Such trees are performance-wise same as linked list.A degenerate or pathological tree is the tree having a single child either left or right","<b>Skewed Binary Tree</b>: A skewed binary tree is a pathological/degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: left-skewed binary tree and right-skewed binary tree"])},f={defination:r.W.setHeader("A binary search tree (BST), also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree. The time complexity of operations on the binary search tree is directly proportional to the height of the tree"),properties:r.W.setListwithTitleHtml("Properties",["The left subtree of a node contains only nodes with keys lesser than the node\u2019s key","The right subtree of a node contains only nodes with keys greater than the node\u2019s key","The left and right subtree each must also be a binary search tree"]),example:r.W.setExampleImage("Example","assets/ds-image/binary-search-tree.jpg"),operations:r.W.setListwithTitleHtml("Operations",["<b>Searching in a BST</b>:Searching in BST involves the comparison of the key values. If the key value is equal to root key then, search successful, if lesser than root key then search the key in the left subtree and if the key is greater than root key then search the key in the right subtree","<b>Insertion in a BST</b>:Insertion in BST involves the comparison of the key values. If the key value is lesser than or equal to root key then go to left subtree, find an empty space following to the search algorithm and insert the data and if the key is greater than root key then go to right subtree, find an empty space following to the search algorithm and insert the data","<b>Deletion in a BST</b>:Deletion in BST involves three cases.<br>Case 1- If the node to be deleted is leaf node: If the node to be deleted is a leaf node, then delete it.<br>Case 2- If the node to be deleted has one child: If the node to be deleted has one child then, delete the node and place the child of the node at the position of the deleted node. <br>Case 3- If the node to be deleted has two children: If the node to be deleted has two children then, find the inorder successor or inorder predecessor of the node according to the nearest capable value of the node to be deleted. Delete the inorder successor or predecessor using the above cases. Replace the node with the inorder successor or predecessor.","<b>Traversals in a BST</b>:There are 4 types of traversals of the Binary Search Tree.<br>Level Order Traversal: Each node of the tree is traversed level by level in order of its appearance.<br>Pre-order Traversal: The nodes are traversed in the format of root and then left subtree and then right subtree.<br>Inorder Traversal: The nodes are traversed in the format of left subtree and then root and then right subtree.<br>Post Traversal: The nodes are traversed in the format of left subtree  and then right subtree and then root"]),advantage:r.W.setListwithTitleHtml("Advantage",["BST is fast in insertion and deletion when balanced","BST is efficient","We can also do range queries \u2013 find keys between N and M (N <= M)","BST code is simple as compared to other data structures"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["The main disadvantage is that we should always implement a balanced binary search tree. Otherwise the cost of operations may not be logarithmic and degenerate into a linear search on an array","Accessing the element in BST is slightly slower than array","A BST can be imbalanced or degenerated which can increase the complexity"]),applications:r.W.setListwithTitleHtml("Applications",["BSTs are used for indexing","It is also used to implement various searching algorithms","IT can be used to implement various data structures","BSTs are used for indexing in databases","BSTs are used to implement Huffman coding algorithm","It is also used to implement dictionaries"])},u={defination:r.W.setHeader("An AVL tree in data structure is a binary tree that is self-balanced by checking the balance factor of every node. It means that the height of the left subtree and the right subtree is balanced. The balance factor should either be -1, 0, or 1. The maximum height difference between the left and right sub-trees can only be 1. In case, the difference is greater than 1, then we must re-balance the tree to make it valid using rotation techniques"),properties:r.W.setListwithTitleHtml("Properties",["The heights of the two child subtrees of any node differ by at most one","Balance Factor = (Height of Left Subtree \u2013 Height of Right Subtree)","-1 Balance factor represents that the right subtree is one level higher than the left subtree","0 Balance factor represents that the height of the left subtree is equal to the height of the right subtree","1 Balance factor means that the left subtree is one level higher than the right subtree","AVL trees are used where search operation is more frequent compared to insert and delete operations","The time complexity of insert, delete, and search operation is O(log N)","AVL trees follow all properties of Binary Search Trees"]),example:r.W.setExampleImage("Example","assets/ds-image/avl-tree.jpg"),operations:r.W.setListwithTitleHtml("Operations",["To make the AVL Tree balance itself, when inserting or deleting a node from the tree, rotations are performed","Left \u2013 Left Rotation:This rotation is performed when a new node is inserted at the left child of the left subtree.<br> A single right rotation is performed. This type of rotation is identified when a node has a balanced factor as +2, and its left-child has a balance factor as +1","Right \u2013 Right Rotation:This rotation is performed when a new node is inserted at the right child of the right subtree.<br>A single left rotation is performed. This type of rotation is identified when a node has a balanced factor as -2, and its right-child has a balance factor as -1","Right \u2013 Left Rotation:This rotation is performed when a new node is inserted at the right child of the left subtree.<br>This rotation is performed when a node has a balance factor as \u20132, and its right-child has a balance factor as +1","Left \u2013 Right Rotation:This rotation is performed when a new node is inserted at the left child of the right subtree.<br>This rotation is performed when a node has a balance factor as +2, and its left-child has a balance factor as -1","Insertion in AVL Trees:Insert operation is almost the same as in simple binary search trees. After every insertion, we balance the height of the tree. Insert operation takes O(log n) worst time complexity.<br>Step 1: Insert the node in the AVL tree using the same insertion algorithm of BST.<br>Step 2: Once the node is added, the balance factor of each node is updated.<br>Step 3: Now check if any node violates the range of the balance factor if the balance factor is violated, then perform rotations using the below case.<br>Case1:If BF(node) = +2 and BF(node -> left-child) = +1, perform LL rotation.<br> Case2:If BF(node) = -2 and BF(node -> right-child) = 1, perform RR rotation.<br>Case3:If BF(node) = -2 and BF(node -> right-child) = +1, perform RL rotation.<br>Case4:If BF(node) = +2 and BF(node -> left-child) = -1, perform LR rotation.","Deletion in AVL Trees:Deletion is also very straight forward. We delete using the same logic as in simple binary search trees. After deletion, we restructure the tree, if needed, to maintain its balanced height.<br>Step 1: Delete the node, as per the BST Deletion.<br>Step 2: Two cases are possible:-<br>Case 1: Deleting from the right subtree.<br>1A. If BF(node) = +2 and BF(node -> left-child) = +1, perform LL rotation.<br>1B. If BF(node) = +2 and BF(node -> left-child) = -1, perform LR rotation.<br>1C. If BF(node) = +2 and BF(node -> left-child) = 0, perform LL rotation.<br>Case 2: Deleting from left subtree.<br>2A. If BF(node) = -2 and BF(node -> right-child) = -1, perform RR rotation.<br>2B. If BF(node) = -2 and BF(node -> right-child) = +1, perform RL rotation.<br>2C. If BF(node) = -2 and BF(node -> right-child) = 0, perform RR rotation."]),advantage:r.W.setListwithTitleHtml("Advantage",["AVL trees provide faster lookups than Red-Black Trees because they are more strictly balanced","AVL trees are used in databases where faster retrievals are required","The height of the AVL tree is always balanced. The height never grows beyond log N, where N is the total number of nodes in the tree","It gives better search time complexity when compared to simple Binary Search trees","AVL trees have self-balancing capabilities"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["AVL trees provide complex insertion and removal operations as more rotations are done due to relatively relaxed balancing","Take more processing for balancing"]),applications:r.W.setListwithTitleHtml("Applications",["In-memory sorts of sets and dictionaries","Database applications that require frequent lookups for data"])},b={defination:r.W.setHeader("B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like AVL and Red-Black Trees), it is assumed that everything is in main memory. To understand the use of B-Trees, we must think of the huge amount of data that cannot fit in main memory. When the number of keys is high, the data is read from disk in the form of blocks. Disk access time is very high compared to the main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses. Most of the tree operations (search, insert, delete, max, min, ..etc ) require O(h) disk accesses where h is the height of the tree. B-tree is a fat tree. The height of B-Trees is kept low by putting maximum possible keys in a B-Tree node. Generally, the B-Tree node size is kept equal to the disk block size. Since the height of the B-tree is low so total disk accesses for most of the operations are reduced significantly compared to balanced Binary Search Trees like AVL Tree, Red-Black Tree, ..etc."),properties:r.W.setListwithTitleHtml("Properties",["All leaves are at the same level","A B-Tree is defined by the term minimum degree \u2018t\u2019. The value of t depends upon disk block size","Every node except root must contain at least t-1 keys. The root may contain minimum 1 key","All nodes (including root) may contain at most 2*t \u2013 1 keys","Number of children of a node is equal to the number of keys in it plus 1","All keys of a node are sorted in increasing order. The child between two keys k1 and k2 contains all keys in the range from k1 and k2","B-Tree grows and shrinks from the root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward","Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(log n)","Insertion of a Node in B-Tree happens only at Leaf Node"]),example:r.W.setExampleImage("Example","assets/ds-image/b-tree.jpg"),operations:r.W.setListwithTitleHtml("Operations",["?"]),advantage:r.W.setListwithTitleHtml("Advantage",["B-Tree facilitates ordered sequential access, and so it works effectively as compared to a hash table","It allows iterations over items in a much similar way as what is supported by a binary tree. The iterations arrange the items in the proper order (ascending or descending) as required","The tree can have millions of items stored in it, and through its flat structure, it facilitates easy and efficient traversal through the data","When there are millions of records, then deleting a record from a table can turn out to be expensive, because the table may need to be rewritten. However, if B-Tree is used to handle sequential access to the table, or if the entire data is stored in B-Tree nodes, then deletion operation can be made simpler"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["?"])},y={defination:r.W.setHeader("A Heap is a special Tree-based data structure in which the tree is a complete binary tree. Generally, Heaps can be of two types:<br> <b class='text-warning'>Max-Heap</b>: In a Max-Heap the key present at the root node must be greatest among the keys present at all of it\u2019s children. The same property must be recursively true for all sub-trees in that Binary Tree.<br> <b class='text-warning'>Min-Heap</b>: In a Min-Heap the key present at the root node must be minimum among the keys present at all of it\u2019s children. The same property must be recursively true for all sub-trees in that Binary Tree."),properties:r.W.setListwithTitleHtml("Properties",["<b>Ordering</b>:Nodes must be arranged in an order according to values. The values should follow min-heap or max-heap property","<b>Structural</b>:All levels in a heap should be full. In other words, it should be a complete binary tree","Array based implementation, so the last parent node index is always (n/2)-1 and the indexs of left child and right child of nay parent node whose index is `i` are (2i+1) and (2i+2) respectively"]),example:r.W.setExampleImage("Example","assets/ds-image/heap-tree.jpg"),operations:r.W.setListwithTitleHtml("Operations",["Heapify:Process to rearrange the heap in order to maintain heap-property","Find-max (or Find-min):find a maximum item of a max-heap, or a minimum item of a min-heap, respectively","Insertion:process to insert an element in existing heap time complexity O(log N)","Deletion: deleting the top element of the heap or the highest priority element, and then organizing the heap and returning the element with time complexity O(log N)","Extract Min-Max \u2192 Returning and deleting the maximum or minimum element in max-heap and min-heap respectively"]),advantage:r.W.setListwithTitleHtml("Advantage",["Less time complexity, for inserting or deleting an element in the heap the time complexity is just O(log N)","It helps to find the minimum number and greatest number","To just peek at the most prior element the time complexity is constant O(1)","Can be implemented using an array, it doesn\u2019t need any extra space for pointer","A binary heap is a balanced binary tree, and easy to implement","Heap can be created with O(N) time"]),disadvantage:r.W.setListwithTitleHtml("Disadvantage",["The time complexity for searching an element in Heap is O(N)","To find a successor or predecessor of an element, the heap takes O(N) time, whereas BST takes only O(log N) time","To print all elements of the heap in sorted order time complexity is O(N*log N), whereas, for BST, it takes only O(N) time","Memory management is more complex in heap memory because it is used globally. Heap memory is divided into two parts-old generations and the young generation etc. at java garbage collection"]),applications:r.W.setListwithTitleHtml("Applications",["Heap is used in the construction of priority queues. We can insert, delete, identify the highest priority element, or insert and extract with priority, among other things, in O(log N) time using a priority queue. Although data structures such as BST, AVL trees, and the Red-Black tree can accomplish the same functionalities, they are more complex than heaps.Priority queues themselves have more advanced uses, such as bandwidth control in an n/w router, prims and Dijkstra's algorithm, Huffman coding, and the BFS algorithm","Order statistics: The Heap data structure can be used to find the kth smallest / largest element in an array quickly and effectively","Heap sort is one of the fastest sorting algorithms with time complexity of O(N* log(N), and it\u2019s easy to implement","Best First Search (BFS) is an informed search, where unlike the queue in Breadth-First Search, this technique is implemented using a priority queue","Patient treatment: In a hospital, an emergency patient, or the patient with more injury is treated first. Here the priority is the degree of injury","Systems concerned with security use heap sort, like the Linux kernel"])};let v=(()=>{class e{constructor(e){this.location=e,this.avlTreeMetaData=u}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-avl-tree"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"AVL(Adelson-Velskii and Landis) Tree"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.avlTreeMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.avlTreeMetaData.disadvantage,o.oJD))},styles:[""]}),e})(),w=(()=>{class e{constructor(e){this.location=e,this.bTreeMetaData=b}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-b-tree"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"B-Tree"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.bTreeMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.bTreeMetaData.disadvantage,o.oJD))},styles:[""]}),e})(),T=(()=>{class e{constructor(e){this.location=e,this.binarySearchTreeMetaData=f}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-binary-search-tree"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Binary Search Tree"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.binarySearchTreeMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binarySearchTreeMetaData.disadvantage,o.oJD))},styles:[""]}),e})(),x=(()=>{class e{constructor(e){this.location=e,this.binaryTreeMetaData=g}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-binary-tree"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Binary Tree"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.binaryTreeMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.type,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.binaryTreeMetaData.disadvantage,o.oJD))},styles:[""]}),e})(),k=(()=>{class e{constructor(e){this.location=e,this.heapMetaData=y}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-heap-tree"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Heap"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.heapMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.heapMetaData.disadvantage,o.oJD))},styles:[""]}),e})();function D(e,t){if(1&e&&(o.TgZ(0,"div",7),o.TgZ(1,"p",8),o._uU(2),o.qZA(),o.qZA()),2&e){const e=t.$implicit;o.Q6J("routerLink",e.url),o.xp6(2),o.Oqu(e.type)}}let H=(()=>{class e{constructor(e){this.location=e,this.treeMetaData=p,this.treeTypesMetaData=m}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-tree"]],decls:16,vars:9,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","flex-wrap","align-items-center"],["class","box p-lg-2 p-1 px-lg-3 px-2 btn me-lg-4 me-3 mb-2",3,"routerLink",4,"ngFor","ngForOf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","btn","me-lg-4","me-3","mb-2",3,"routerLink"],[1,"m-0"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Tree"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o.TgZ(10,"div",5),o.YNc(11,D,3,2,"div",6),o.qZA(),o._UZ(12,"div",4),o._UZ(13,"div",4),o._UZ(14,"div",4),o._UZ(15,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.treeMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.terminologies,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.type,o.oJD),o.xp6(2),o.Q6J("ngForOf",t.treeTypesMetaData),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.treeMetaData.disadvantage,o.oJD))},directives:[i.sg,n.rH],styles:[""]}),e})();const J={defination:r.W.setHeader("Trie is a sorted tree-based data-structure that stores the set of strings. It has the number of pointers equal to the number of characters of the alphabet in each node. It can search a word in the dictionary with the help of the word's prefix. For example, if we assume that all strings are formed from the letters 'a' to 'z' in the English alphabet, each trie node can have a maximum of 26 points <br> Trie is also known as the digital tree or prefix tree. The position of a node in the Trie determines the key with which that node is connected"),properties:r.W.setListwithTitleHtml("Properties",["The root node of the trie always represents the null node","Each child of nodes is sorted alphabetically","Each node can have a maximum of 26 children (A to Z)","Each node (except the root) can store one letter of the alphabet"]),example:r.W.setExampleImage("Example","assets/ds-image/trie.jpg"),operations:r.W.setListwithTitleHtml("Operations",["Insertion of a node: <br> Every letter of the input key (word) is inserted as an individual in the Trie_node. Note that children point to the next level of Trie nodes.<br>The key character array acts as an index of children.<br>If the present node already has a reference to the present letter, set the present node to that referenced node. Otherwise, create a new node, set the letter to be equal to the present letter, and even start the present node with this new node.<br> The character length determines the depth of the trie","Searching a node in Trie: The searching operation is similar to the insertion operation. The search operation is used to search a key in the trie","Deletion of a node in the Trie:<br> If the key is not found in the trie, the delete operation will stop and exit it.<br>If the key is found in the trie, delete it from the trie."]),applications:r.W.setListwithTitleHtml("Applications",["<b>Spell Checker</b>:Spell checking is a three-step process. First, look for that word in a dictionary, generate possible suggestions, and then sort the suggestion words with the desired word at the top.<br>Trie is used to store the word in dictionaries. The spell checker can easily be applied in the most efficient way by searching for words on a data structure. Using trie not only makes it easy to see the word in the dictionary, but it is also simple to build an algorithm to include a collection of relevant words or suggestions","<b>Auto-complete</b>:Auto-complete functionality is widely used on text editors, mobile applications, and the Internet. It provides a simple way to find an alternative word to complete the word","<b>Browser history</b>:It is also used to complete the URL in the browser. The browser keeps a history of the URLs of the websites you've visited"]),advantage:r.W.setListwithTitleHtml("Advantages",["It can be insert faster and search the string than hash tables and binary search trees","It provides an alphabetical filter of entries by the key of the node"]),disadvantage:r.W.setListwithTitleHtml("Disadvantages",["It requires more memory to store the strings","It is slower than the hash table"])},A=[{path:"",redirectTo:"tree",pathMatch:"full"},{path:"tree",component:H},{path:"binary-tree",component:x},{path:"binary-search-tree",component:T},{path:"avl-tree",component:v},{path:"b-tree",component:w},{path:"heap-tree",component:k},{path:"graph",component:h},{path:"trie",component:(()=>{class e{constructor(e){this.location=e,this.trieMetaData=J}ngOnInit(){}gotoBack(){this.location.back()}}return e.\u0275fac=function(t){return new(t||e)(o.Y36(i.Ye))},e.\u0275cmp=o.Xpm({type:e,selectors:[["app-trie"]],decls:13,vars:7,consts:[[1,"d-flex","align-items-center","float-start","btn","bg-info","px-lg-3","px-2","py-lg-2","py-1","mt-5",3,"click"],["src","assets/icons/Back-white.png","alt",""],[1,"m-0","ms-1","text-light","fw-bold","d-lg-block","d-none"],[1,"text-center","mt-4","pt-3"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(o.TgZ(0,"div",0),o.NdJ("click",function(){return t.gotoBack()}),o._UZ(1,"img",1),o.TgZ(2,"p",2),o._uU(3,"Back"),o.qZA(),o.qZA(),o.TgZ(4,"h1",3),o._uU(5,"Trie"),o.qZA(),o._UZ(6,"div",4),o._UZ(7,"div",4),o._UZ(8,"div",4),o._UZ(9,"div",4),o._UZ(10,"div",4),o._UZ(11,"div",4),o._UZ(12,"div",4)),2&e&&(o.xp6(6),o.Q6J("innerHtml",t.trieMetaData.defination,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.example,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.operations,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.properties,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.applications,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.advantage,o.oJD),o.xp6(1),o.Q6J("innerHtml",t.trieMetaData.disadvantage,o.oJD))},styles:[""]}),e})()},{path:"hash-table",component:d}];let B=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=o.oAB({type:e}),e.\u0275inj=o.cJS({imports:[[n.Bz.forChild(A)],n.Bz]}),e})(),Z=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=o.oAB({type:e}),e.\u0275inj=o.cJS({imports:[[i.ez,B]]}),e})()}}]);