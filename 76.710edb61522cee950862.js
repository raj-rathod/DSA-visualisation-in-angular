(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[76],{6076:(t,e,n)=>{"use strict";n.r(e),n.d(e,{SortingModule:()=>T});var o=n(8583),s=n(2389),r=n(3018);let i=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-bubble-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),a=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-bucket-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),l=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-counting-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),c=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-insertion-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),m=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-merge-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),p=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-quick-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})(),h=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-radix-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})();var u=n(1077);const d={defination:u.W.setHeader("A sorting algorithm is a method for reorganizing a large number of items into a specific order, \n    such as alphabetical, highest-to-lowest value or shortest-to-longest distance. Sorting algorithms take lists of \n    items as input data, perform specific operations on those lists and deliver ordered arrays as output"),properties:u.W.setListwithTitleHtml("Characteristics of Sorting Algorithms",["<b>Speed (or better: time complexity)</b>: The most important criterion when selecting a sorting method is its speed. \n          The main point of interest here is how the speed changes depending on the number of elements to be sorted.<br> After all,\n          one algorithm can be twice as fast as another at a hundred elements, but at a thousand elements, it can be five times slower","<b>Space complexity</b>: Not only time complexity is relevant for sorting methods, but also space complexity. \n          Space complexity specifies how much additional memory the algorithm requires depending on the number of \n          elements to be sorted. This does not refer to the memory required for the elements themselves, \n          but to the additional memory required for auxiliary variables, loop counters, and temporary arrays","<b>Stability</b>:  In stable sorting methods, the relative sequence of elements that have the same sort key is maintained. \n          This is not guaranteed for non-stable sort methods: The relative order can be maintained but does not have to be","<b>Comparison sorts / non-comparison sorts</b>:  Most of the well-known sorting methods are based on the comparison \n          of two elements on less, greater or equal. However, there are also non-comparison-based sorting algorithms.<br> \n          You can find out how this can work in the Counting Sort and Radix Sort sections","<b>Recursive / non-recursive</b>:  A recursive sorting algorithm requires additional memory on the stack. \n          If the recursion is too deep, the dreaded StackOverflowExecption is imminent"]),classifications:u.W.setListwithTitleHtml("Classification of Sorting Algorithm",["Based on Number of Swaps or Inversion This is the number of times the algorithm swaps elements to sort the input. \n        Selection Sort requires the minimum number of swaps","Based on Number of Comparisons This is the number of times the algorithm compares elements to sort the input. \n        Using Big-O notation, the sorting algorithm examples listed above require at least O(nlogn) comparisons in the best \n        case and O(n^2) comparisons in the worst case for most of the outputs","Based on Recursion or Non-Recursion Some sorting algorithms, such as Quick Sort, use recursive techniques to sort the input. \n        Other sorting algorithms, such as Selection Sort or Insertion Sort, use non-recursive techniques. Finally, some sorting \n        algorithm, such as Merge Sort, make use of both recursive as well as non-recursive techniques to sort the input","Based on Stability Sorting algorithms are said to be stable if the algorithm maintains the relative order of elements with \n        equal keys. In other words, two equivalent elements remain in the same order in the sorted output as they were in the input","Insertion sort, Merge Sort, and Bubble Sort are stable","Heap Sort and Quick Sort are not stable","Based on Extra Space Requirement Sorting algorithms are said to be in place if they require a constant O(1) extra \n        space for sorting","Insertion sort and Quick-sort are in place sort as we move the elements about the pivot and do not actually use a \n        separate array which is NOT the case in merge sort where the size of the input must be allocated beforehand to store \n        the output during the sort","Merge Sort is an example of out place sort as it require extra memory space for it\u2019s operations"]),example:u.W.setExampleImage("Complexity and Stability of Sorting Algorithms","assets/ds-image/sorting.jpg ")},g={defination:u.W.setHeader("Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based \n    algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.\n    Initially, the sorted part is empty and the unsorted part is the entire list. <br>\n    The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes \n    a part of the sorted array. This process continues moving unsorted array boundary by one element to the right."),properties:u.W.setListwithTitleHtml("Selection Sort Properties",["This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, \n        the sorted part at the left end and the unsorted part at the right end","Selection Sort requires the minimum number of swaps."]),explainImage:u.W.setExampleImage("Selection Sort Explain Image","assets/ds-image/explainImage.jpg"),flowChart:u.W.setExampleImage("Selection Sort Flowchart","assets/ds-image/selection-sort.jpg"),advantage:u.W.setListwithTitleHtml("Selection Sort Advantages",["The main advantage of the selection sort is that it performs well on a small list","It is an in-place sorting algorithm, no additional temporary storage is required beyond \n          what is needed to hold the original list"]),disadvantage:u.W.setListwithTitleHtml("Selection Sort Disadvantages",["The primary disadvantage of the selection sort is its poor efficiency when dealing with a huge list of items","Similar to the bubble sort, the selection sort requires n-squared number of steps for sorting n elements."]),applications:u.W.setListwithTitleHtml("Selection Sort Applications",["a small list is to be sorted","cost of swapping does not matter","checking of all the elements is compulsory","cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)"]),workingProcedure:u.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Initialize minimum value(minValue) to location 0.","Traverse the array to find the minimum element in the array.","While traversing if any element smaller than minValue is found then swap both the values.","Then, increment minValue to point to the next element.","Repeat until the array is sorted."])};let f=(()=>{class t{constructor(){this.selectionSortMetaData=g}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-selection-sort"]],decls:10,vars:8,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1,"Selection Sort Algorithm"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1)),2&t&&(r.xp6(2),r.Q6J("innerHtml",e.selectionSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.selectionSortMetaData.disadvantage,r.oJD))},styles:[""]}),t})(),b=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-shell-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),t})();var v=n(4912);function w(t,e){if(1&t&&(r.TgZ(0,"div",5),r.TgZ(1,"p",6),r._uU(2),r.qZA(),r.qZA()),2&t){const t=r.oxw().$implicit;r.Q6J("routerLink",t.route),r.xp6(2),r.Oqu(t.name)}}function y(t,e){if(1&t&&(r.ynx(0),r.YNc(1,w,3,2,"div",4),r.BQk()),2&t){const t=e.index;r.xp6(1),r.Q6J("ngIf",0!=t)}}const x=[{path:"",component:(()=>{class t{constructor(){this.sortingMetaData=d,this.sortingType=v.wr}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=r.Xpm({type:t,selectors:[["app-sorting-algorithm"]],decls:8,vars:5,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","align-items-center","horizontal-scroll"],[4,"ngFor","ngForOf"],["class","box p-lg-2 p-1 px-lg-3 px-2 tab me-lg-4 me-3",3,"routerLink",4,"ngIf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","tab","me-lg-4","me-3",3,"routerLink"],[1,"m-0"]],template:function(t,e){1&t&&(r.TgZ(0,"h1",0),r._uU(1,"Sorting Algorithms"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r.TgZ(4,"div",2),r.YNc(5,y,2,1,"ng-container",3),r.qZA(),r._UZ(6,"div",1),r._UZ(7,"div",1)),2&t&&(r.xp6(2),r.Q6J("innerHtml",e.sortingMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.sortingMetaData.properties,r.oJD),r.xp6(2),r.Q6J("ngForOf",e.sortingType),r.xp6(1),r.Q6J("innerHtml",e.sortingMetaData.classifications,r.oJD),r.xp6(1),r.Q6J("innerHtml",e.sortingMetaData.example,r.oJD))},directives:[o.sg,o.O5,s.rH],styles:[""]}),t})()},{path:"bubble-sort",component:i},{path:"selection-sort",component:f},{path:"insertion-sort",component:c},{path:"merge-sort",component:m},{path:"quick-sort",component:p},{path:"counting-sort",component:l},{path:"radix-sort",component:h},{path:"bucket-sort",component:a},{path:"shell-sort",component:b}];let S=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=r.oAB({type:t}),t.\u0275inj=r.cJS({imports:[[s.Bz.forChild(x)],s.Bz]}),t})(),T=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=r.oAB({type:t}),t.\u0275inj=r.cJS({imports:[[o.ez,S]]}),t})()}}]);