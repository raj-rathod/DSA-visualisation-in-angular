(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[76],{6076:(t,e,i)=>{"use strict";i.r(e),i.d(e,{SortingModule:()=>I});var o=i(8583),n=i(2389),a=i(3018);let r=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-bubble-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Coming soon"),a.qZA())},styles:[""]}),t})(),s=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-bucket-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Coming soon"),a.qZA())},styles:[""]}),t})();var l=i(1077);const m={defination:l.W.setHeader("A sorting algorithm is a method for reorganizing a large number of items into a specific order, \n    such as alphabetical, highest-to-lowest value or shortest-to-longest distance. Sorting algorithms take lists of \n    items as input data, perform specific operations on those lists and deliver ordered arrays as output"),properties:l.W.setListwithTitleHtml("Characteristics of Sorting Algorithms",["<b>Speed (or better: time complexity)</b>: The most important criterion when selecting a sorting method is its speed. \n          The main point of interest here is how the speed changes depending on the number of elements to be sorted.<br> After all,\n          one algorithm can be twice as fast as another at a hundred elements, but at a thousand elements, it can be five times slower","<b>Space complexity</b>: Not only time complexity is relevant for sorting methods, but also space complexity. \n          Space complexity specifies how much additional memory the algorithm requires depending on the number of \n          elements to be sorted. This does not refer to the memory required for the elements themselves, \n          but to the additional memory required for auxiliary variables, loop counters, and temporary arrays","<b>Stability</b>:  In stable sorting methods, the relative sequence of elements that have the same sort key is maintained. \n          This is not guaranteed for non-stable sort methods: The relative order can be maintained but does not have to be","<b>Comparison sorts / non-comparison sorts</b>:  Most of the well-known sorting methods are based on the comparison \n          of two elements on less, greater or equal. However, there are also non-comparison-based sorting algorithms.<br> \n          You can find out how this can work in the Counting Sort and Radix Sort sections","<b>Recursive / non-recursive</b>:  A recursive sorting algorithm requires additional memory on the stack. \n          If the recursion is too deep, the dreaded StackOverflowExecption is imminent"]),classifications:l.W.setListwithTitleHtml("Classification of Sorting Algorithm",["Based on Number of Swaps or Inversion This is the number of times the algorithm swaps elements to sort the input. \n        Selection Sort requires the minimum number of swaps","Based on Number of Comparisons This is the number of times the algorithm compares elements to sort the input. \n        Using Big-O notation, the sorting algorithm examples listed above require at least O(nlogn) comparisons in the best \n        case and O(n^2) comparisons in the worst case for most of the outputs","Based on Recursion or Non-Recursion Some sorting algorithms, such as Quick Sort, use recursive techniques to sort the input. \n        Other sorting algorithms, such as Selection Sort or Insertion Sort, use non-recursive techniques. Finally, some sorting \n        algorithm, such as Merge Sort, make use of both recursive as well as non-recursive techniques to sort the input","Based on Stability Sorting algorithms are said to be stable if the algorithm maintains the relative order of elements with \n        equal keys. In other words, two equivalent elements remain in the same order in the sorted output as they were in the input","Insertion sort, Merge Sort, and Bubble Sort are stable","Heap Sort and Quick Sort are not stable","Based on Extra Space Requirement Sorting algorithms are said to be in place if they require a constant O(1) extra \n        space for sorting","Insertion sort and Quick-sort are in place sort as we move the elements about the pivot and do not actually use a \n        separate array which is NOT the case in merge sort where the size of the input must be allocated beforehand to store \n        the output during the sort","Merge Sort is an example of out place sort as it require extra memory space for it\u2019s operations"]),example:l.W.setExampleImage("Complexity and Stability of Sorting Algorithms","assets/ds-image/sorting.jpg ")},h={defination:l.W.setHeader("Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based \n    algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.\n    Initially, the sorted part is empty and the unsorted part is the entire list. <br>\n    The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes \n    a part of the sorted array. This process continues moving unsorted array boundary by one element to the right."),properties:l.W.setListwithTitleHtml("Selection Sort Properties",["This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, \n        the sorted part at the left end and the unsorted part at the right end","Selection Sort requires the minimum number of swaps."]),explainImage:l.W.setExampleImage("Selection Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:l.W.setExampleImage("Selection Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:l.W.setListwithTitleHtml("Selection Sort Advantages",["The main advantage of the selection sort is that it performs well on a small list","It is an in-place sorting algorithm, no additional temporary storage is required beyond \n          what is needed to hold the original list"]),disadvantage:l.W.setListwithTitleHtml("Selection Sort Disadvantages",["The primary disadvantage of the selection sort is its poor efficiency when dealing with a huge list of items","Similar to the bubble sort, the selection sort requires n-squared number of steps for sorting n elements."]),applications:l.W.setListwithTitleHtml("Selection Sort Applications",["a small list is to be sorted","cost of swapping does not matter","checking of all the elements is compulsory","cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Initialize minimum value(minValue) to location 0.","Traverse the array to find the minimum element in the array.","While traversing if any element smaller than minValue is found then swap both the values.","Then, increment minValue to point to the next element.","Repeat until the array is sorted."])},p={defination:l.W.setHeader("Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards \n    in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part \n    are picked and placed at the correct position in the sorted part"),properties:l.W.setListwithTitleHtml("Insertion Sort Properties",["This algorithm is one of the simplest algorithm with simple implementation","Basically, Insertion sort is efficient for small data values","Insertion sort is adaptive in nature, i.e. it is appropriate for data sets which are already partially sorted","Insertion sort is an in-place algorithm, meaning it requires no extra space","Maintains relative order of the input data in case of two equal values (stable)","the bubble sort performs poorly compared to the insertion sort. Due to the high number of swaps, \n      it's expected to generate twice as many write operations and twice as many cache misses","Insertion sort's advantage is that it only scans as many elements as it needs in order to place the k+1st element,\n      while selection sort must scan all remaining elements to find the k+1st element. Experiments show that insertion \n      sort usually performs about half as many comparisons as selection sort"]),explainImage:l.W.setExampleImage("Insertion Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:l.W.setExampleImage("Insertion Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:l.W.setListwithTitleHtml("Insertion Sort Advantages",["The main advantage of the insertion sort is its simplicity. It also exhibits a good performance when dealing with a small list. \n      The insertion sort is an in-place sorting algorithm so the space requirement is minimal"]),disadvantage:l.W.setListwithTitleHtml("Insertion Sort Disadvantages",["The disadvantage of the insertion sort is that it does not perform as well as other, better sorting algorithms. \n     With n-squared steps required for every n element to be sorted, the insertion sort does not deal well with a huge list. \n     Therefore, the insertion sort is particularly useful only when sorting a list of few items"]),applications:l.W.setListwithTitleHtml("Insertion Sort Applications",["One more real-world example of insertion sort is how tailors arrange shirts in a cupboard, they always keep them in sorted \n     order of size and thus insert new shirts at the right position very quickly by moving other shirts forward to keep the right \n     place for a new shirt"]),other:l.W.setListwithTitleHtml("Insertion Sort Performance",["Worst-case performance of insertion sort is O(n\xb2) comparisons and swaps","Best-case performance is O(n) comparisons and O(1) swaps","Average-case performance is O(n\xb2) comparisons and swaps"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Iterate from arr[1] to arr[N] over the array","Compare the current element (key) to its predecessor","If the key element is smaller than its predecessor, compare it to the elements before. \n    Move the greater elements one position up to make space for the swapped element"])},c={defination:l.W.setHeader("The Merge Sort algorithm is a sorting algorithm that is based on the Divide and Conquer paradigm. In this algorithm, \n    the array is initially divided into two equal halves and then they are combined in a sorted manner\n    </br>\n    Think of it as a recursive algorithm continuously splits the array in half until it cannot be further divided. \n    This means that if the array becomes empty or has only one element left, the dividing will stop, \n    i.e. it is the base case to stop the recursion. If the array has multiple elements, split the array into \n    halves and recursively invoke the merge sort on each of the halves. Finally, when both halves are sorted, \n    the merge operation is applied. Merge operation is the process of taking two smaller sorted arrays and \n    combining them to eventually make a larger one\n  "),properties:l.W.setListwithTitleHtml("Merge Sort Properties",["Merge Sort is useful for sorting linked lists.","Merge Sort is a stable sort which means that the same element in an array maintain \n      their original positions with respect to each other.","Overall time complexity of Merge sort is O(nLogn). It is more efficient as it is in worst \n      case also the runtime is O(nlogn)","The space complexity of Merge sort is O(n). This means that this algorithm takes a lot of space and may \n      slower down operations for the last data sets."]),explainImage:l.W.setExampleImage("Merge Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:l.W.setExampleImage("Merge Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:l.W.setListwithTitleHtml("Merge Sort Advantages",["Merge sort can efficiently sort a list in O(n*log(n)) time","Fast for large arrays unlike selection, insertion, and bubble sort it doesn't go through the whole array many times"]),disadvantage:l.W.setListwithTitleHtml("Merge Sort Disadvantages",["For small datasets, merge sort is slower than other sorting algorithms","For the temporary array, mergesort requires an additional space of O(n)","Even if the array is sorted, the merge sort goes through the entire process"]),applications:l.W.setListwithTitleHtml("Merge Sort Applications",["Merge Sort is useful for sorting linked lists in O(n Log n) time","Merge sort can be implemented without extra space for linked lists","Merge sort is used for counting inversions in a list","Merge sort is used in external sorting"]),other:l.W.setListwithTitleHtml("Merge Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(n*log n)","Best Case Time Complexity [Big-omega]: O(n*log n)","Average Time Complexity [Big-theta]: O(n*log n)","Space Complexity: O(n)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["mergeSort(arr[], l,  r)","If r > l","Find the middle point to divide the array into two halves: middle m = l + (r \u2013 l)/2","Call mergeSort for first half: mergeSort(arr, l, m)","Call mergeSort for second half: mergeSort(arr, m + 1, r)","Merge the two halves sorted in steps 2 and 3: merge(arr, l, m, r)"])},d={defination:l.W.setHeader('Quick sort is a fast sorting algorithm used to sort a list of elements. Quick sort algorithm is \n    invented by C. A. R. Hoare.\n    </br>\n    The quick sort algorithm attempts to separate the list of elements into two parts and then sort each part recursively. \n    That means it use divide and conquer strategy. In quick sort, the partition of the list is performed based on the \n    element called pivot. Here pivot element is one of the elements in the list.\n    </br>\n    The list is divided into two partitions such that "all elements to the left of pivot are smaller than the pivot \n    and all elements to the right of pivot are greater than or equal to the pivot".\n  '),properties:l.W.setListwithTitleHtml("Quick Sort Properties",["Quick Sort is useful for sorting arrays","In efficient implementations Quick Sort is not a stable sort, meaning that the relative order of equal \n      sort items is not preserved","Overall time complexity of Quick Sort is O(nlogn). In the worst case, it makes O(n**2) comparisons, \n      though this behavior is rare","The space complexity of Quick Sort is O(logn). It is an in-place sort (i.e. it doesn\u2019t require any extra storage)"]),explainImage:l.W.setExampleImage("Quick Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:l.W.setExampleImage("Quick Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:l.W.setListwithTitleHtml("Quick Sort Advantages",["It is in-place since it uses only a small auxiliary stack","It requires only n (log n) time to sort n items","It has an extremely short inner loop"]),disadvantage:l.W.setListwithTitleHtml("Quick Sort Disadvantages",["It is recursive. Especially, if recursion is not available, the implementation is extremely complicated","It requires quadratic (i.e., n**2) time in the worst-case","It is fragile, i.e. a simple mistake in the implementation can go unnoticed and cause it to perform badly"]),applications:l.W.setListwithTitleHtml("Quick Sort Applications",["Commercial Computing is used in various government and private organizations for the purpose of sorting various data like \n      sorting files by name/date/price, sorting of students by their roll no., sorting of account profile by given id, etc.","The sorting algorithm is used for information searching and as Quicksort is the fastest algorithm so it is \n      widely used as a better way of searching","It is used everywhere where a stable sort is not needed","Quicksort is a cache-friendly algorithm as it has a good locality of reference when used for arrays","It is tail -recursive and hence all the call optimization can be done","It is an in-place sort that does not require any extra storage memory","Variants of Quicksort are used to separate the Kth smallest or largest elements"]),other:l.W.setListwithTitleHtml("Quick Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(n**2)","Best Case Time Complexity [Big-omega]: O(nlog n)","Average Time Complexity [Big-theta]: O(nlog n)","Space Complexity: O(logn)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Consider the first element of the list as pivot (i.e., Element at first position in the list)","Define two variables i and j. Set i and j to first and last elements of the list respectively","Increment i until list[i] > pivot then stop","Decrement j until list[j] < pivot then stop","If i < j then exchange list[i] and list[j]","Repeat steps 3,4 & 5 until i > j","Exchange the pivot element with list[j] element"])},g={defination:l.W.setHeader("Counting sort is a sorting algorithm that sorts the elements of an array by counting the number \n    of occurrences of each unique element in the array. The count is stored in an auxiliary array and \n    the sorting is done by mapping the count as an index of the auxiliary array."),properties:l.W.setListwithTitleHtml("Counting Sort Properties",["Like other algorithms this sorting algorithm is not a comparison-based algorithm, \n     it hashes the value in a temporary count array and uses them for sorting","It uses a temporary array making it a non In Place algorithm","Counting sort is not a stable algorithm. But it can be made stable with some code changes","It is often used as a sub-routine to another sorting algorithm like radix sort","Counting sort can be extended to work for negative inputs also"]),explainImage:l.W.setExampleImage("Counting Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:l.W.setExampleImage("Counting Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:l.W.setListwithTitleHtml("Counting Sort Advantages",["Counting sort generally performs faster than all comparison-based sorting algorithms, \n    such as merge sort and quicksort, if the range of input is of the order of the number of input","Counting sort is easy to code"]),disadvantage:l.W.setListwithTitleHtml("Counting Sort Disadvantages",["Counting sort doesn\u2019t work on decimal values","Counting sort is inefficient if the range of values to be sorted is very large"]),applications:l.W.setListwithTitleHtml("Counting Sort Applications",["If the range of input data is not much bigger than the number of objects to be sorted, counting sort is efficient\n      </br>\n      Consider the following scenario: the data is 10, 5, 10K, 5K, and the input sequence is 1 to 10K\n    ","It isn't a sorting system based on comparisons. It has an O(n) running time complexity, \n     with space proportional to the data range","Counting sort counts the occurrences of the data object in O using partial hashing (1)"]),other:l.W.setListwithTitleHtml("Counting Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(N+M)","Best Case Time Complexity [Big-omega]: O(N+M)","Average Time Complexity [Big-theta]: O(N+M)","Space Complexity: O(N+M)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Iterate through the input array to find the highest value","Declare a new array with the value 0 and a size of max+1","Count each element in the array and increment its value in the auxiliary array generated at the corresponding index","Add current and previous frequency to the auxiliary array to find the cumulative sum","The cumulative value now represents the element's actual position in the sorted input array","Begin iterating through the auxiliary array from 0 to max","Put 0 at the corresponding index and reduce the count by 1, which will indicate the element's \n      second position in the input array if it exists","Now put the array you got in the previous step into the actual input array"])};let u=(()=>{class t{constructor(){this.countingSortMetaData=g}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-counting-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1,"Counting Sort"),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a._UZ(4,"div",1),a._UZ(5,"div",1),a._UZ(6,"div",1),a._UZ(7,"div",1),a._UZ(8,"div",1),a._UZ(9,"div",1),a._UZ(10,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.countingSortMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.explainImage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.properties,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.flowChart,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.workingProcedure,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.applications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.other,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.advantage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.countingSortMetaData.disadvantage,a.oJD))},styles:[""]}),t})(),f=(()=>{class t{constructor(){this.insertionSortMetaData=p}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-insertion-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1,"Insertion Sort"),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a._UZ(4,"div",1),a._UZ(5,"div",1),a._UZ(6,"div",1),a._UZ(7,"div",1),a._UZ(8,"div",1),a._UZ(9,"div",1),a._UZ(10,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.insertionSortMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.explainImage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.properties,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.flowChart,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.workingProcedure,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.applications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.other,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.advantage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.insertionSortMetaData.disadvantage,a.oJD))},styles:[""]}),t})(),v=(()=>{class t{constructor(){this.mergeSortMetaData=c}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-merge-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Merge Sort "),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a._UZ(4,"div",1),a._UZ(5,"div",1),a._UZ(6,"div",1),a._UZ(7,"div",1),a._UZ(8,"div",1),a._UZ(9,"div",1),a._UZ(10,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.mergeSortMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.explainImage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.properties,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.flowChart,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.workingProcedure,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.applications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.other,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.advantage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.mergeSortMetaData.disadvantage,a.oJD))},styles:[""]}),t})(),y=(()=>{class t{constructor(){this.quickSortMetaData=d}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-quick-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Quick Sort "),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a._UZ(4,"div",1),a._UZ(5,"div",1),a._UZ(6,"div",1),a._UZ(7,"div",1),a._UZ(8,"div",1),a._UZ(9,"div",1),a._UZ(10,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.quickSortMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.explainImage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.properties,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.flowChart,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.workingProcedure,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.applications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.other,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.advantage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.quickSortMetaData.disadvantage,a.oJD))},styles:[""]}),t})(),w=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-radix-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Coming soon"),a.qZA())},styles:[""]}),t})(),x=(()=>{class t{constructor(){this.selectionSortMetaData=h}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-selection-sort"]],decls:10,vars:8,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1,"Selection Sort"),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a._UZ(4,"div",1),a._UZ(5,"div",1),a._UZ(6,"div",1),a._UZ(7,"div",1),a._UZ(8,"div",1),a._UZ(9,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.selectionSortMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.explainImage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.properties,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.flowChart,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.workingProcedure,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.applications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.advantage,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.selectionSortMetaData.disadvantage,a.oJD))},styles:[""]}),t})(),S=(()=>{class t{constructor(){}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-shell-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1," Coming soon"),a.qZA())},styles:[""]}),t})();var b=i(4912);function D(t,e){if(1&t&&(a.TgZ(0,"div",5),a.TgZ(1,"p",6),a._uU(2),a.qZA(),a.qZA()),2&t){const t=a.oxw().$implicit;a.Q6J("routerLink",t.route),a.xp6(2),a.Oqu(t.name)}}function J(t,e){if(1&t&&(a.ynx(0),a.YNc(1,D,3,2,"div",4),a.BQk()),2&t){const t=e.index;a.xp6(1),a.Q6J("ngIf",0!=t)}}const H=[{path:"",component:(()=>{class t{constructor(){this.sortingMetaData=m,this.sortingType=b.wr}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=a.Xpm({type:t,selectors:[["app-sorting-algorithm"]],decls:8,vars:5,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","align-items-center","horizontal-scroll"],[4,"ngFor","ngForOf"],["class","box p-lg-2 p-1 px-lg-3 px-2 tab me-lg-4 me-3",3,"routerLink",4,"ngIf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","tab","me-lg-4","me-3",3,"routerLink"],[1,"m-0"]],template:function(t,e){1&t&&(a.TgZ(0,"h1",0),a._uU(1,"Sorting Algorithms"),a.qZA(),a._UZ(2,"div",1),a._UZ(3,"div",1),a.TgZ(4,"div",2),a.YNc(5,J,2,1,"ng-container",3),a.qZA(),a._UZ(6,"div",1),a._UZ(7,"div",1)),2&t&&(a.xp6(2),a.Q6J("innerHtml",e.sortingMetaData.defination,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.sortingMetaData.properties,a.oJD),a.xp6(2),a.Q6J("ngForOf",e.sortingType),a.xp6(1),a.Q6J("innerHtml",e.sortingMetaData.classifications,a.oJD),a.xp6(1),a.Q6J("innerHtml",e.sortingMetaData.example,a.oJD))},directives:[o.sg,o.O5,n.rH],styles:[""]}),t})()},{path:"bubble-sort",component:r},{path:"selection-sort",component:x},{path:"insertion-sort",component:f},{path:"merge-sort",component:v},{path:"quick-sort",component:y},{path:"counting-sort",component:u},{path:"radix-sort",component:w},{path:"bucket-sort",component:s},{path:"shell-sort",component:S}];let k=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=a.oAB({type:t}),t.\u0275inj=a.cJS({imports:[[n.Bz.forChild(H)],n.Bz]}),t})(),I=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=a.oAB({type:t}),t.\u0275inj=a.cJS({imports:[[o.ez,k]]}),t})()}}]);