(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[76],{6076:(e,t,i)=>{"use strict";i.r(t),i.d(t,{SortingModule:()=>C});var a=i(8583),o=i(701),r=i(8720);let n=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-bubble-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Coming soon"),r.qZA())},styles:[""]}),e})();var s=i(7238),l=i(1077);const m={defination:l.W.setHeader("A sorting algorithm is a method for reorganizing a large number of items into a specific order, \n    such as alphabetical, highest-to-lowest value or shortest-to-longest distance. Sorting algorithms take lists of \n    items as input data, perform specific operations on those lists and deliver ordered arrays as output"),properties:l.W.setListwithTitleHtml("Characteristics of Sorting Algorithms",["<b>Speed (or better: time complexity)</b>: The most important criterion when selecting a sorting method is its speed. \n          The main point of interest here is how the speed changes depending on the number of elements to be sorted.<br> After all,\n          one algorithm can be twice as fast as another at a hundred elements, but at a thousand elements, it can be five times slower","<b>Space complexity</b>: Not only time complexity is relevant for sorting methods, but also space complexity. \n          Space complexity specifies how much additional memory the algorithm requires depending on the number of \n          elements to be sorted. This does not refer to the memory required for the elements themselves, \n          but to the additional memory required for auxiliary variables, loop counters, and temporary arrays","<b>Stability</b>:  In stable sorting methods, the relative sequence of elements that have the same sort key is maintained. \n          This is not guaranteed for non-stable sort methods: The relative order can be maintained but does not have to be","<b>Comparison sorts / non-comparison sorts</b>:  Most of the well-known sorting methods are based on the comparison \n          of two elements on less, greater or equal. However, there are also non-comparison-based sorting algorithms.<br> \n          You can find out how this can work in the Counting Sort and Radix Sort sections","<b>Recursive / non-recursive</b>:  A recursive sorting algorithm requires additional memory on the stack. \n          If the recursion is too deep, the dreaded StackOverflowExecption is imminent"]),classifications:l.W.setListwithTitleHtml("Classification of Sorting Algorithm",["Based on Number of Swaps or Inversion This is the number of times the algorithm swaps elements to sort the input. \n        Selection Sort requires the minimum number of swaps","Based on Number of Comparisons This is the number of times the algorithm compares elements to sort the input. \n        Using Big-O notation, the sorting algorithm examples listed above require at least O(nlogn) comparisons in the best \n        case and O(n^2) comparisons in the worst case for most of the outputs","Based on Recursion or Non-Recursion Some sorting algorithms, such as Quick Sort, use recursive techniques to sort the input. \n        Other sorting algorithms, such as Selection Sort or Insertion Sort, use non-recursive techniques. Finally, some sorting \n        algorithm, such as Merge Sort, make use of both recursive as well as non-recursive techniques to sort the input","Based on Stability Sorting algorithms are said to be stable if the algorithm maintains the relative order of elements with \n        equal keys. In other words, two equivalent elements remain in the same order in the sorted output as they were in the input","Insertion sort, Merge Sort, and Bubble Sort are stable","Heap Sort and Quick Sort are not stable","Based on Extra Space Requirement Sorting algorithms are said to be in place if they require a constant O(1) extra \n        space for sorting","Insertion sort and Quick-sort are in place sort as we move the elements about the pivot and do not actually use a \n        separate array which is NOT the case in merge sort where the size of the input must be allocated beforehand to store \n        the output during the sort","Merge Sort is an example of out place sort as it require extra memory space for it\u2019s operations"]),example:l.W.setExampleImage("Complexity and Stability of Sorting Algorithms","assets/ds-image/sorting.jpg ")},h={defination:l.W.setHeader("Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based \n    algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.\n    Initially, the sorted part is empty and the unsorted part is the entire list. <br>\n    The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes \n    a part of the sorted array. This process continues moving unsorted array boundary by one element to the right."),properties:l.W.setListwithTitleHtml("Selection Sort Properties",["This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, \n        the sorted part at the left end and the unsorted part at the right end","Selection Sort requires the minimum number of swaps."]),explainImage:l.W.setExampleImage("Selection Sort Explain Image","assets/ds-image/selection-sort.jpg"),flowChart:l.W.setExampleImage("Selection Sort Flowchart","assets/ds-image/selection-sort-flowchart.jpg"),advantage:l.W.setListwithTitleHtml("Selection Sort Advantages",["The main advantage of the selection sort is that it performs well on a small list","It is an in-place sorting algorithm, no additional temporary storage is required beyond \n          what is needed to hold the original list"]),disadvantage:l.W.setListwithTitleHtml("Selection Sort Disadvantages",["The primary disadvantage of the selection sort is its poor efficiency when dealing with a huge list of items","Similar to the bubble sort, the selection sort requires n-squared number of steps for sorting n elements."]),applications:l.W.setListwithTitleHtml("Selection Sort Applications",["a small list is to be sorted","cost of swapping does not matter","checking of all the elements is compulsory","cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Initialize minimum value(minValue) to location 0.","Traverse the array to find the minimum element in the array.","While traversing if any element smaller than minValue is found then swap both the values.","Then, increment minValue to point to the next element.","Repeat until the array is sorted."])},c={defination:l.W.setHeader("Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards \n    in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part \n    are picked and placed at the correct position in the sorted part"),properties:l.W.setListwithTitleHtml("Insertion Sort Properties",["This algorithm is one of the simplest algorithm with simple implementation","Basically, Insertion sort is efficient for small data values","Insertion sort is adaptive in nature, i.e. it is appropriate for data sets which are already partially sorted","Insertion sort is an in-place algorithm, meaning it requires no extra space","Maintains relative order of the input data in case of two equal values (stable)","the bubble sort performs poorly compared to the insertion sort. Due to the high number of swaps, \n      it's expected to generate twice as many write operations and twice as many cache misses","Insertion sort's advantage is that it only scans as many elements as it needs in order to place the k+1st element,\n      while selection sort must scan all remaining elements to find the k+1st element. Experiments show that insertion \n      sort usually performs about half as many comparisons as selection sort"]),explainImage:l.W.setExampleImage("Insertion Sort Explain Image","assets/ds-image/insertion-sort.jpg"),flowChart:l.W.setExampleImage("Insertion Sort Flowchart","assets/ds-image/insertion-sort-flowchart.jpg"),advantage:l.W.setListwithTitleHtml("Insertion Sort Advantages",["The main advantage of the insertion sort is its simplicity. It also exhibits a good performance when dealing with a small list. \n      The insertion sort is an in-place sorting algorithm so the space requirement is minimal"]),disadvantage:l.W.setListwithTitleHtml("Insertion Sort Disadvantages",["The disadvantage of the insertion sort is that it does not perform as well as other, better sorting algorithms. \n     With n-squared steps required for every n element to be sorted, the insertion sort does not deal well with a huge list. \n     Therefore, the insertion sort is particularly useful only when sorting a list of few items"]),applications:l.W.setListwithTitleHtml("Insertion Sort Applications",["One more real-world example of insertion sort is how tailors arrange shirts in a cupboard, they always keep them in sorted \n     order of size and thus insert new shirts at the right position very quickly by moving other shirts forward to keep the right \n     place for a new shirt"]),other:l.W.setListwithTitleHtml("Insertion Sort Performance",["Worst-case performance of insertion sort is O(n\xb2) comparisons and swaps","Best-case performance is O(n) comparisons and O(1) swaps","Average-case performance is O(n\xb2) comparisons and swaps"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Iterate from arr[1] to arr[N] over the array","Compare the current element (key) to its predecessor","If the key element is smaller than its predecessor, compare it to the elements before. \n    Move the greater elements one position up to make space for the swapped element"])},d={defination:l.W.setHeader("The Merge Sort algorithm is a sorting algorithm that is based on the Divide and Conquer paradigm. In this algorithm, \n    the array is initially divided into two equal halves and then they are combined in a sorted manner\n    </br>\n    Think of it as a recursive algorithm continuously splits the array in half until it cannot be further divided. \n    This means that if the array becomes empty or has only one element left, the dividing will stop, \n    i.e. it is the base case to stop the recursion. If the array has multiple elements, split the array into \n    halves and recursively invoke the merge sort on each of the halves. Finally, when both halves are sorted, \n    the merge operation is applied. Merge operation is the process of taking two smaller sorted arrays and \n    combining them to eventually make a larger one\n  "),properties:l.W.setListwithTitleHtml("Merge Sort Properties",["Merge Sort is useful for sorting linked lists.","Merge Sort is a stable sort which means that the same element in an array maintain \n      their original positions with respect to each other.","Overall time complexity of Merge sort is O(nLogn). It is more efficient as it is in worst \n      case also the runtime is O(nlogn)","The space complexity of Merge sort is O(n). This means that this algorithm takes a lot of space and may \n      slower down operations for the last data sets."]),explainImage:l.W.setExampleImage("Merge Sort Explain Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Merge Sort Flowchart","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Merge Sort Advantages",["Merge sort can efficiently sort a list in O(n*log(n)) time","Fast for large arrays unlike selection, insertion, and bubble sort it doesn't go through the whole array many times"]),disadvantage:l.W.setListwithTitleHtml("Merge Sort Disadvantages",["For small datasets, merge sort is slower than other sorting algorithms","For the temporary array, mergesort requires an additional space of O(n)","Even if the array is sorted, the merge sort goes through the entire process"]),applications:l.W.setListwithTitleHtml("Merge Sort Applications",["Merge Sort is useful for sorting linked lists in O(n Log n) time","Merge sort can be implemented without extra space for linked lists","Merge sort is used for counting inversions in a list","Merge sort is used in external sorting"]),other:l.W.setListwithTitleHtml("Merge Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(n*log n)","Best Case Time Complexity [Big-omega]: O(n*log n)","Average Time Complexity [Big-theta]: O(n*log n)","Space Complexity: O(n)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["mergeSort(arr[], l,  r)","If r > l","Find the middle point to divide the array into two halves: middle m = l + (r \u2013 l)/2","Call mergeSort for first half: mergeSort(arr, l, m)","Call mergeSort for second half: mergeSort(arr, m + 1, r)","Merge the two halves sorted in steps 2 and 3: merge(arr, l, m, r)"])},p={defination:l.W.setHeader('Quick sort is a fast sorting algorithm used to sort a list of elements. Quick sort algorithm is \n    invented by C. A. R. Hoare.\n    </br>\n    The quick sort algorithm attempts to separate the list of elements into two parts and then sort each part recursively. \n    That means it use divide and conquer strategy. In quick sort, the partition of the list is performed based on the \n    element called pivot. Here pivot element is one of the elements in the list.\n    </br>\n    The list is divided into two partitions such that "all elements to the left of pivot are smaller than the pivot \n    and all elements to the right of pivot are greater than or equal to the pivot".\n  '),properties:l.W.setListwithTitleHtml("Quick Sort Properties",["Quick Sort is useful for sorting arrays","In efficient implementations Quick Sort is not a stable sort, meaning that the relative order of equal \n      sort items is not preserved","Overall time complexity of Quick Sort is O(nlogn). In the worst case, it makes O(n**2) comparisons, \n      though this behavior is rare","The space complexity of Quick Sort is O(logn). It is an in-place sort (i.e. it doesn\u2019t require any extra storage)"]),explainImage:l.W.setExampleImage("Quick Sort Explain Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Quick Sort Flowchart","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Quick Sort Advantages",["It is in-place since it uses only a small auxiliary stack","It requires only n (log n) time to sort n items","It has an extremely short inner loop"]),disadvantage:l.W.setListwithTitleHtml("Quick Sort Disadvantages",["It is recursive. Especially, if recursion is not available, the implementation is extremely complicated","It requires quadratic (i.e., n**2) time in the worst-case","It is fragile, i.e. a simple mistake in the implementation can go unnoticed and cause it to perform badly"]),applications:l.W.setListwithTitleHtml("Quick Sort Applications",["Commercial Computing is used in various government and private organizations for the purpose of sorting various data like \n      sorting files by name/date/price, sorting of students by their roll no., sorting of account profile by given id, etc.","The sorting algorithm is used for information searching and as Quicksort is the fastest algorithm so it is \n      widely used as a better way of searching","It is used everywhere where a stable sort is not needed","Quicksort is a cache-friendly algorithm as it has a good locality of reference when used for arrays","It is tail -recursive and hence all the call optimization can be done","It is an in-place sort that does not require any extra storage memory","Variants of Quicksort are used to separate the Kth smallest or largest elements"]),other:l.W.setListwithTitleHtml("Quick Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(n**2)","Best Case Time Complexity [Big-omega]: O(nlog n)","Average Time Complexity [Big-theta]: O(nlog n)","Space Complexity: O(logn)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Consider the first element of the list as pivot (i.e., Element at first position in the list)","Define two variables i and j. Set i and j to first and last elements of the list respectively","Increment i until list[i] > pivot then stop","Decrement j until list[j] < pivot then stop","If i < j then exchange list[i] and list[j]","Repeat steps 3,4 & 5 until i > j","Exchange the pivot element with list[j] element"])},u={defination:l.W.setHeader("Counting sort is a sorting algorithm that sorts the elements of an array by counting the number \n    of occurrences of each unique element in the array. The count is stored in an auxiliary array and \n    the sorting is done by mapping the count as an index of the auxiliary array."),properties:l.W.setListwithTitleHtml("Counting Sort Properties",["Like other algorithms this sorting algorithm is not a comparison-based algorithm, \n     it hashes the value in a temporary count array and uses them for sorting","It uses a temporary array making it a non In Place algorithm","Counting sort is not a stable algorithm. But it can be made stable with some code changes","It is often used as a sub-routine to another sorting algorithm like radix sort","Counting sort can be extended to work for negative inputs also"]),explainImage:l.W.setExampleImage("Counting Sort Explain Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Counting Sort Flowchart","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Counting Sort Advantages",["Counting sort generally performs faster than all comparison-based sorting algorithms, \n    such as merge sort and quicksort, if the range of input is of the order of the number of input","Counting sort is easy to code"]),disadvantage:l.W.setListwithTitleHtml("Counting Sort Disadvantages",["Counting sort doesn\u2019t work on decimal values","Counting sort is inefficient if the range of values to be sorted is very large","What if the elements are in the range from 1 to n**2? We can\u2019t use counting sort because counting sort will\n     take O(n**2) which is worse than comparison-based sorting algorithms"]),applications:l.W.setListwithTitleHtml("Counting Sort Applications",["If the range of input data is not much bigger than the number of objects to be sorted, counting sort is efficient\n      </br>\n      Consider the following scenario: the data is 10, 5, 10K, 5K, and the input sequence is 1 to 10K\n    ","It isn't a sorting system based on comparisons. It has an O(n) running time complexity, \n     with space proportional to the data range","Counting sort counts the occurrences of the data object in O using partial hashing (1)"]),other:l.W.setListwithTitleHtml("Counting Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(N+M)","Best Case Time Complexity [Big-omega]: O(N+M)","Average Time Complexity [Big-theta]: O(N+M)","Space Complexity: O(N+M)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Iterate through the input array to find the highest value","Declare a new array with the value 0 and a size of max+1","Count each element in the array and increment its value in the auxiliary array generated at the corresponding index","Add current and previous frequency to the auxiliary array to find the cumulative sum","The cumulative value now represents the element's actual position in the sorted input array","Begin iterating through the auxiliary array from 0 to max","Put 0 at the corresponding index and reduce the count by 1, which will indicate the element's \n      second position in the input array if it exists","Now put the array you got in the previous step into the actual input array"])},g={defination:l.W.setHeader("Radix sort is an algorithm that uses counting sort as a subroutine to sort an array of integers/strings in \n    either ascending or descending order. The main idea of radix sort revolves around applying counting sort digit by \n    digit on the given array"),properties:l.W.setListwithTitleHtml("Radix Sort Properties",["It makes assumptions about the data like the data must be between a range of elements","Input array must have the elements with the same radix and width","Radix sort works on sorting based on an individual digit or letter position","We must start sorting from the rightmost position and use a stable algorithm at each position","Radix sort is not an in-place algorithm as it uses a temporary count array"]),explainImage:l.W.setExampleImage("Radix Sort Explain Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Radix Sort Flowchart","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Radix Sort Advantages",["Fast when the keys are short, i.e. when the array element range is small","Used in suffix arrays construction algorithms such as Manber's and the DC3 algorithm","Radix Sort is a stable sort because it maintains the relative order of elements with equal values"]),disadvantage:l.W.setListwithTitleHtml("Radix Sort Disadvantages",["The Radix Sort algorithm is less flexible than other sorts because it is based on digits or letters. \n      As a result, for each different type of data, it must be rewritten","Radix sort has a higher constant than other sorting algorithms","It takes up more space than Quicksort, which is used for in-place sorting","Radix sort may be slower than other sorting algorithms such as merge sort and Quicksort if the operations \n      are inefficient. These operations include sub-inset lists and delete functions, as well as the process \n      of isolating the desired digits","Because it is based on digits or letters, the radix sort is less flexible than other sorts. \n      If the data type must be rewritten, so must the Radix sort"]),applications:l.W.setListwithTitleHtml("Radix Sort Applications",["The Radix sort algorithm is used in a typical computer, a sequential random-access machine, multiple fields key records","While creating a suffix array, use the DC3 algorithm (K\xe4rkk\xe4inen-Sanders-Burkhardt)","The Radix sort algorithm locates locations where there are numbers in extensive ranges"]),other:l.W.setListwithTitleHtml("Radix Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(N+K)","Best Case Time Complexity [Big-omega]: O(N+K)","Average Time Complexity [Big-theta]: O(N+K)","Space Complexity: O(MAX)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Find the maximum element of the array, let it be max","Find the number of digits in max, let it be k","For each, i ranging from 1 To k, apply the counting sort algorithm for the i^{th} \n      least-significant digit of each element. If any element has less than i digits consider 0 at its \n      place (Because 29 can also be represented as 029)"])},f={defination:l.W.setHeader("Bucket sort is a sorting technique that uses the Scatter-Gather-Approach to sort the array. \n    It divides the unsorted array into separate groups and calls them buckets. Sort the individual buckets, \n    and then gather them all together to form the final sorted array"),properties:l.W.setListwithTitleHtml("Properties of Bucket Sort",["Bucket sort assumes that the input is drawn from a uniform distribution","The computational complexity estimates involve the number of buckets","Bucket sort can be exceptionally fast because of the way elements are assigned to buckets, \n      typically using an array where the index is the value","This means that more auxiliary memory is required for the buckets at the cost of running time than more comparison sorts"]),explainImage:l.W.setExampleImage("Bucket Sort Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Flowchart of Bucket Sort","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Advantages of Bucket Sort",["Bucket sort allows each bucket to be processed independently. As a result, you\u2019ll frequently need to \n      sort much smaller arrays as a secondary step after sorting the main array","Bucket sort also has the advantage of being able to be used as an external sorting algorithm. \n      If you need to sort a list that is too large to fit in memory, you may stream it through RAM, \n      split the contents into buckets saved in external files, and then sort each file separately in RAM"]),disadvantage:l.W.setListwithTitleHtml("Disadvantages of Bucket Sort",["The problem is that if the buckets are distributed incorrectly, you may wind up spending a lot of extra \n      effort for no or very little gain. As a result, bucket sort works best when the data is more or \n      less evenly distributed, or when there is a smart technique to pick the buckets given a fast \n      set of heuristics based on the input array","Can\u2019t apply it to all data types since a suitable bucketing technique is required. Bucket sort\u2019s \n      efficiency is dependent on the distribution of the input values, thus it\u2019s not worth it if your\n      data are closely grouped.In many situations, you might achieve greater performance by using a \n      specialized sorting algorithm like radix sort, counting sort, or burst sort instead of bucket sort","Bucket sort\u2019s performance is determined by the number of buckets used, which may need some additional \n      performance adjustment when compared to other algorithms"]),applications:l.W.setListwithTitleHtml("Applications of Bucket Sort",["Uniformly Distributed data","Floating point numbers between range 0.0 to 1.0.","Bucket Sort is a very different type of sorting algorithm as it does not involve direct comparison between \n      the numbers. It can only be applied to uniformly distributed data","Whenever we have floating-point numbers between 0 and 1, bucket sort might be the best sorting approach. \n      Reason - if we use merge-sort, quick-sort, heap-sort, etc, the problem will take a minimum of O(nlogn) \n      time complexity. Also, counting sort cannot be used because floating point numbers cannot be used as index. \n      Hence, bucket sort is best suited for sorting the array with floating point numbers of range [0.0-1.0]"]),other:l.W.setListwithTitleHtml("Performance of Bucket Sort",["<b>Worst Case Time Complexity: O(N**2)</b> </br> If the array elements are not uniformly distributed, \n      i.e., elements are concentrated within specific ranges. This will result in one or more buckets having \n      more elements than other buckets, making bucket sort like any other sorting technique, where every element \n      is compared to the other. Time complexity increases even further if the elements in the array are present \n      in the reverse order. If insertion sort is used, the worst-case time complexity can go up to O(N**2)","<b>Best Case Time Complexity: O(N+K)</b> </br> If the array elements are uniformly distributed, \n      bucket size will almost be the same for all the buckets. Hence, this will be the best case which \n      will take up the least amount of time. Sorting time complexity will reduce even further if all \n      the elements inside each bucket are already sorted. To create n buckets and scatter each element \n      from the array, time complexity = O(n). If we use Insertion sort to sort each bucket, time complexity = O(k). \n      Hence, best case time complexity for bucket sort = O(n+k), where n = number of elements, and k = number of buckets","<b>Average Case Time Complexity: O(N)</b> </br> It occurs when the elements are distributed randomly in the array.\n      Even if the elements are not distributed uniformly, bucket sort runs in linear time. It holds true until the \n      sum of the squares of the bucket sizes is linear in the total number of elements","<b>Space Complexity : O(N+K)</b> </br> Space Complexity for bucket sort is O(n+k), where n = number of elements \n      in the array, and k = number of buckets formed Space taken by each bucket is O(k), and inside each bucket, \n      we have n elements scattered. Hence, the space complexity becomes O(n+k)"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["If All the elements are in the range of [0,1] then no need to follow initial two steps\n    and in third step create 10 empty buckets and in step four bucketIndex = array[i]*10","Calculate the maximum and the minimum element of the array","Calculate the range: range = (maximum - minimum) / n, where n is the number of buckets","Create n empty buckets and initialize them with 0","Loop through the unsorted array and perform the following:\n      </br> (i) Calculate bucketIndex bucketIndex = (array[i] - minimum) / range \n      </br> (ii) Insert the ith element of the array into the bucket[bucketIndex]","Sort the individual buckets","Gather all the elements together"])},b={defination:l.W.setHeader("Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead.\n  When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange \n  of far items. In Shell sort, we make the array gap-sorted for a large value of gap. We keep reducing the value of gap \n  until it becomes 1. An array is said to be gap-sorted if all sublists of every gap\u2019th element are sorted."),properties:l.W.setListwithTitleHtml("Properties of Shell Sort",["Comparison-based sorting technique","Inplace sorting technique just like insertion sort","Works very well for medium-sized datasets","Unstable sorting technique"]),explainImage:l.W.setExampleImage("Shell Sort Image","assets/ds-image/DSA-404.webp"),flowChart:l.W.setExampleImage("Flowchart of Shell Sort","assets/ds-image/DSA-404.webp"),advantage:l.W.setListwithTitleHtml("Advantages of Shell Sort",["Shell sort algorithm is only efficient for finite number of elements in an array","Shell sort algorithm is 5.32 x faster than bubble sort algorithm"]),disadvantage:l.W.setListwithTitleHtml("Disadvantages of Shell Sort",["Shell sort algorithm is complex in structure and bit more difficult to understand","Shell sort algorithm is significantly slower than the merge sort, quick sort and heap sort algorithms"]),applications:l.W.setListwithTitleHtml("Applications of Shell Sort",["Shell sort is a replacement of insertion sort when insertion sort is taking too much execution time","We use shell sort when the call of the stack is overhead"," Shell sort is applicable when recursion exceeds a particular limit"]),other:l.W.setListwithTitleHtml("Performance of Shell Sort",["<b>Worst Case Complexity:</b>  less than or equal to O(n2)","<b>Best Case Complexity:</b> O(n*log n)","<b>Average Case Complexity:</b> O(n*log n) It is around O(n1.25).","<b>Note:</b> The complexity depends on the interval chosen. The above complexities differ for different \n   increment sequences chosen. Best increment sequence is unknown"]),workingProcedure:l.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Initialize the value of gap size. Example: gap"," Divide the list into smaller sub-part. Each must have equal intervals to gap","Sort these sub-lists using insertion sort","Repeat this step 2 until the list is sorted and gap size is 1"])};var v=i(397);let y=(()=>{class e{constructor(){this.bucketSortMetaData=f,this.menuState="out"}ngOnInit(){}sideDrawer(){this.menuState="out"===this.menuState?"in":"out"}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-bucket-sort"]],decls:12,vars:10,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[3,"sideDrawerClose"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Bucket Sort "),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1),r.TgZ(11,"app-code-syntax",2),r.NdJ("sideDrawerClose",function(){return t.sideDrawer()}),r.qZA()),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.bucketSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.bucketSortMetaData.disadvantage,r.oJD),r.xp6(1),r.Q6J("@slideInOut",t.menuState))},directives:[v.s],styles:[""],data:{animation:[(0,s.X$)("slideInOut",[(0,s.SB)("in",(0,s.oB)({transform:"translate3d(0,0,0)"})),(0,s.SB)("out",(0,s.oB)({transform:"translate3d(100%, 0, 0)"})),(0,s.eR)("in => out",(0,s.jt)("400ms ease-in-out")),(0,s.eR)("out => in",(0,s.jt)("400ms ease-in-out"))])]}}),e})(),w=(()=>{class e{constructor(){this.countingSortMetaData=u}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-counting-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1,"Counting Sort"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.countingSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.countingSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),x=(()=>{class e{constructor(){this.insertionSortMetaData=c}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-insertion-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","col-md-7",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1,"Insertion Sort"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",2),r._UZ(5,"div",2),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.insertionSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.insertionSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),S=(()=>{class e{constructor(){this.mergeSortMetaData=d}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-merge-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Merge Sort "),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.mergeSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.mergeSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),k=(()=>{class e{constructor(){this.quickSortMetaData=p}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-quick-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Quick Sort "),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.quickSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.quickSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),D=(()=>{class e{constructor(){this.radixSortMetaData=g}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-radix-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Radix Sort "),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.radixSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.radixSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),J=(()=>{class e{constructor(){this.selectionSortMetaData=h}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-selection-sort"]],decls:10,vars:8,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","col-md-7",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1,"Selection Sort"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",2),r._UZ(6,"div",2),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.selectionSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.selectionSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})(),H=(()=>{class e{constructor(){this.shellSortMetaData=b}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-shell-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1," Shell Sort "),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r._UZ(4,"div",1),r._UZ(5,"div",1),r._UZ(6,"div",1),r._UZ(7,"div",1),r._UZ(8,"div",1),r._UZ(9,"div",1),r._UZ(10,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.shellSortMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.explainImage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.properties,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.flowChart,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.workingProcedure,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.applications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.other,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.advantage,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.shellSortMetaData.disadvantage,r.oJD))},styles:[""]}),e})();var I=i(4912);function T(e,t){if(1&e&&(r.ynx(0),r.TgZ(1,"div",4),r.TgZ(2,"p",5),r._uU(3),r.qZA(),r.qZA(),r.BQk()),2&e){const e=t.$implicit;r.xp6(1),r.Q6J("routerLink",e.route),r.xp6(2),r.Oqu(e.name)}}const M=[{path:"",component:(()=>{class e{constructor(){this.sortingMetaData=m,this.sortingType=I.wr}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=r.Xpm({type:e,selectors:[["app-sorting-algorithm"]],decls:8,vars:5,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","align-items-center","horizontal-scroll"],[4,"ngFor","ngForOf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","tab","me-lg-4","me-3",3,"routerLink"],[1,"m-0"]],template:function(e,t){1&e&&(r.TgZ(0,"h1",0),r._uU(1,"Sorting Algorithms"),r.qZA(),r._UZ(2,"div",1),r._UZ(3,"div",1),r.TgZ(4,"div",2),r.YNc(5,T,4,2,"ng-container",3),r.qZA(),r._UZ(6,"div",1),r._UZ(7,"div",1)),2&e&&(r.xp6(2),r.Q6J("innerHtml",t.sortingMetaData.defination,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.sortingMetaData.properties,r.oJD),r.xp6(2),r.Q6J("ngForOf",t.sortingType),r.xp6(1),r.Q6J("innerHtml",t.sortingMetaData.classifications,r.oJD),r.xp6(1),r.Q6J("innerHtml",t.sortingMetaData.example,r.oJD))},directives:[a.sg,o.rH],styles:[""]}),e})()},{path:"bubble-sort",component:n},{path:"selection-sort",component:J},{path:"insertion-sort",component:x},{path:"merge-sort",component:S},{path:"quick-sort",component:k},{path:"counting-sort",component:w},{path:"radix-sort",component:D},{path:"bucket-sort",component:y},{path:"shell-sort",component:H}];let Z=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=r.oAB({type:e}),e.\u0275inj=r.cJS({imports:[[o.Bz.forChild(M)],o.Bz]}),e})();var Q=i(990);let C=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=r.oAB({type:e}),e.\u0275inj=r.cJS({imports:[[a.ez,Z,Q.m]]}),e})()}}]);