(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[76],{6076:(e,t,o)=>{"use strict";o.r(t),o.d(t,{SortingModule:()=>T});var r=o(8583),n=o(2389),s=o(3018);let i=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-bubble-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})(),a=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-bucket-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})(),l=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-counting-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})();var m=o(1077);const h={defination:m.W.setHeader("A sorting algorithm is a method for reorganizing a large number of items into a specific order, \n    such as alphabetical, highest-to-lowest value or shortest-to-longest distance. Sorting algorithms take lists of \n    items as input data, perform specific operations on those lists and deliver ordered arrays as output"),properties:m.W.setListwithTitleHtml("Characteristics of Sorting Algorithms",["<b>Speed (or better: time complexity)</b>: The most important criterion when selecting a sorting method is its speed. \n          The main point of interest here is how the speed changes depending on the number of elements to be sorted.<br> After all,\n          one algorithm can be twice as fast as another at a hundred elements, but at a thousand elements, it can be five times slower","<b>Space complexity</b>: Not only time complexity is relevant for sorting methods, but also space complexity. \n          Space complexity specifies how much additional memory the algorithm requires depending on the number of \n          elements to be sorted. This does not refer to the memory required for the elements themselves, \n          but to the additional memory required for auxiliary variables, loop counters, and temporary arrays","<b>Stability</b>:  In stable sorting methods, the relative sequence of elements that have the same sort key is maintained. \n          This is not guaranteed for non-stable sort methods: The relative order can be maintained but does not have to be","<b>Comparison sorts / non-comparison sorts</b>:  Most of the well-known sorting methods are based on the comparison \n          of two elements on less, greater or equal. However, there are also non-comparison-based sorting algorithms.<br> \n          You can find out how this can work in the Counting Sort and Radix Sort sections","<b>Recursive / non-recursive</b>:  A recursive sorting algorithm requires additional memory on the stack. \n          If the recursion is too deep, the dreaded StackOverflowExecption is imminent"]),classifications:m.W.setListwithTitleHtml("Classification of Sorting Algorithm",["Based on Number of Swaps or Inversion This is the number of times the algorithm swaps elements to sort the input. \n        Selection Sort requires the minimum number of swaps","Based on Number of Comparisons This is the number of times the algorithm compares elements to sort the input. \n        Using Big-O notation, the sorting algorithm examples listed above require at least O(nlogn) comparisons in the best \n        case and O(n^2) comparisons in the worst case for most of the outputs","Based on Recursion or Non-Recursion Some sorting algorithms, such as Quick Sort, use recursive techniques to sort the input. \n        Other sorting algorithms, such as Selection Sort or Insertion Sort, use non-recursive techniques. Finally, some sorting \n        algorithm, such as Merge Sort, make use of both recursive as well as non-recursive techniques to sort the input","Based on Stability Sorting algorithms are said to be stable if the algorithm maintains the relative order of elements with \n        equal keys. In other words, two equivalent elements remain in the same order in the sorted output as they were in the input","Insertion sort, Merge Sort, and Bubble Sort are stable","Heap Sort and Quick Sort are not stable","Based on Extra Space Requirement Sorting algorithms are said to be in place if they require a constant O(1) extra \n        space for sorting","Insertion sort and Quick-sort are in place sort as we move the elements about the pivot and do not actually use a \n        separate array which is NOT the case in merge sort where the size of the input must be allocated beforehand to store \n        the output during the sort","Merge Sort is an example of out place sort as it require extra memory space for it\u2019s operations"]),example:m.W.setExampleImage("Complexity and Stability of Sorting Algorithms","assets/ds-image/sorting.jpg ")},p={defination:m.W.setHeader("Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based \n    algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.\n    Initially, the sorted part is empty and the unsorted part is the entire list. <br>\n    The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes \n    a part of the sorted array. This process continues moving unsorted array boundary by one element to the right."),properties:m.W.setListwithTitleHtml("Selection Sort Properties",["This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, \n        the sorted part at the left end and the unsorted part at the right end","Selection Sort requires the minimum number of swaps."]),explainImage:m.W.setExampleImage("Selection Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:m.W.setExampleImage("Selection Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:m.W.setListwithTitleHtml("Selection Sort Advantages",["The main advantage of the selection sort is that it performs well on a small list","It is an in-place sorting algorithm, no additional temporary storage is required beyond \n          what is needed to hold the original list"]),disadvantage:m.W.setListwithTitleHtml("Selection Sort Disadvantages",["The primary disadvantage of the selection sort is its poor efficiency when dealing with a huge list of items","Similar to the bubble sort, the selection sort requires n-squared number of steps for sorting n elements."]),applications:m.W.setListwithTitleHtml("Selection Sort Applications",["a small list is to be sorted","cost of swapping does not matter","checking of all the elements is compulsory","cost of writing to a memory matters like in flash memory (number of writes/swaps is O(n) as compared to O(n2) of bubble sort)"]),workingProcedure:m.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Initialize minimum value(minValue) to location 0.","Traverse the array to find the minimum element in the array.","While traversing if any element smaller than minValue is found then swap both the values.","Then, increment minValue to point to the next element.","Repeat until the array is sorted."])},c={defination:m.W.setHeader("Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards \n    in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part \n    are picked and placed at the correct position in the sorted part"),properties:m.W.setListwithTitleHtml("Insertion Sort Properties",["This algorithm is one of the simplest algorithm with simple implementation","Basically, Insertion sort is efficient for small data values","Insertion sort is adaptive in nature, i.e. it is appropriate for data sets which are already partially sorted","Insertion sort is an in-place algorithm, meaning it requires no extra space","Maintains relative order of the input data in case of two equal values (stable)","the bubble sort performs poorly compared to the insertion sort. Due to the high number of swaps, \n      it's expected to generate twice as many write operations and twice as many cache misses","Insertion sort's advantage is that it only scans as many elements as it needs in order to place the k+1st element,\n      while selection sort must scan all remaining elements to find the k+1st element. Experiments show that insertion \n      sort usually performs about half as many comparisons as selection sort"]),explainImage:m.W.setExampleImage("Insertion Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:m.W.setExampleImage("Insertion Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:m.W.setListwithTitleHtml("Insertion Sort Advantages",["The main advantage of the insertion sort is its simplicity. It also exhibits a good performance when dealing with a small list. \n      The insertion sort is an in-place sorting algorithm so the space requirement is minimal"]),disadvantage:m.W.setListwithTitleHtml("Insertion Sort Disadvantages",["The disadvantage of the insertion sort is that it does not perform as well as other, better sorting algorithms. \n     With n-squared steps required for every n element to be sorted, the insertion sort does not deal well with a huge list. \n     Therefore, the insertion sort is particularly useful only when sorting a list of few items"]),applications:m.W.setListwithTitleHtml("Insertion Sort Applications",["One more real-world example of insertion sort is how tailors arrange shirts in a cupboard, they always keep them in sorted \n     order of size and thus insert new shirts at the right position very quickly by moving other shirts forward to keep the right \n     place for a new shirt"]),other:m.W.setListwithTitleHtml("Insertion Sort Performance",["Worst-case performance of insertion sort is O(n\xb2) comparisons and swaps","Best-case performance is O(n) comparisons and O(1) swaps","Average-case performance is O(n\xb2) comparisons and swaps"]),workingProcedure:m.W.setListwithTitleHtml("Follow the below steps to solve the problem",["Iterate from arr[1] to arr[N] over the array","Compare the current element (key) to its predecessor","If the key element is smaller than its predecessor, compare it to the elements before. \n    Move the greater elements one position up to make space for the swapped element"])},d={defination:m.W.setHeader("The Merge Sort algorithm is a sorting algorithm that is based on the Divide and Conquer paradigm. In this algorithm, \n    the array is initially divided into two equal halves and then they are combined in a sorted manner\n    </br>\n    Think of it as a recursive algorithm continuously splits the array in half until it cannot be further divided. \n    This means that if the array becomes empty or has only one element left, the dividing will stop, \n    i.e. it is the base case to stop the recursion. If the array has multiple elements, split the array into \n    halves and recursively invoke the merge sort on each of the halves. Finally, when both halves are sorted, \n    the merge operation is applied. Merge operation is the process of taking two smaller sorted arrays and \n    combining them to eventually make a larger one\n  "),properties:m.W.setListwithTitleHtml("Merge Sort Properties",["Merge Sort is useful for sorting linked lists.","Merge Sort is a stable sort which means that the same element in an array maintain \n      their original positions with respect to each other.","Overall time complexity of Merge sort is O(nLogn). It is more efficient as it is in worst \n      case also the runtime is O(nlogn)","The space complexity of Merge sort is O(n). This means that this algorithm takes a lot of space and may \n      slower down operations for the last data sets."]),explainImage:m.W.setExampleImage("Merge Sort Explain Image","assets/ds-image/DSA1.jpg"),flowChart:m.W.setExampleImage("Merge Sort Flowchart","assets/ds-image/DSA1.jpg"),advantage:m.W.setListwithTitleHtml("Merge Sort Advantages",["Merge sort can efficiently sort a list in O(n*log(n)) time","Fast for large arrays unlike selection, insertion, and bubble sort it doesn't go through the whole array many times"]),disadvantage:m.W.setListwithTitleHtml("Merge Sort Disadvantages",["For small datasets, merge sort is slower than other sorting algorithms","For the temporary array, mergesort requires an additional space of O(n)","Even if the array is sorted, the merge sort goes through the entire process"]),applications:m.W.setListwithTitleHtml("Merge Sort Applications",["Merge Sort is useful for sorting linked lists in O(n Log n) time","Merge sort can be implemented without extra space for linked lists","Merge sort is used for counting inversions in a list","Merge sort is used in external sorting"]),other:m.W.setListwithTitleHtml("Merge Sort Performance",["Worst Case Time Complexity [ Big-O ]: O(n*log n)","Best Case Time Complexity [Big-omega]: O(n*log n)","Average Time Complexity [Big-theta]: O(n*log n)","Space Complexity: O(n)"]),workingProcedure:m.W.setListwithTitleHtml("Follow the below steps to solve the problem",["mergeSort(arr[], l,  r)","If r > l","Find the middle point to divide the array into two halves: middle m = l + (r \u2013 l)/2","Call mergeSort for first half: mergeSort(arr, l, m)","Call mergeSort for second half: mergeSort(arr, m + 1, r)","Merge the two halves sorted in steps 2 and 3: merge(arr, l, m, r)"])};let g=(()=>{class e{constructor(){this.insertionSortMetaData=c}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-insertion-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1,"Insertion Sort"),s.qZA(),s._UZ(2,"div",1),s._UZ(3,"div",1),s._UZ(4,"div",1),s._UZ(5,"div",1),s._UZ(6,"div",1),s._UZ(7,"div",1),s._UZ(8,"div",1),s._UZ(9,"div",1),s._UZ(10,"div",1)),2&e&&(s.xp6(2),s.Q6J("innerHtml",t.insertionSortMetaData.defination,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.explainImage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.properties,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.flowChart,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.workingProcedure,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.applications,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.other,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.advantage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.insertionSortMetaData.disadvantage,s.oJD))},styles:[""]}),e})(),u=(()=>{class e{constructor(){this.mergeSortMetaData=d}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-merge-sort"]],decls:11,vars:9,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Merge Sort "),s.qZA(),s._UZ(2,"div",1),s._UZ(3,"div",1),s._UZ(4,"div",1),s._UZ(5,"div",1),s._UZ(6,"div",1),s._UZ(7,"div",1),s._UZ(8,"div",1),s._UZ(9,"div",1),s._UZ(10,"div",1)),2&e&&(s.xp6(2),s.Q6J("innerHtml",t.mergeSortMetaData.defination,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.explainImage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.properties,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.flowChart,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.workingProcedure,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.applications,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.other,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.advantage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.mergeSortMetaData.disadvantage,s.oJD))},styles:[""]}),e})(),f=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-quick-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})(),w=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-radix-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})(),v=(()=>{class e{constructor(){this.selectionSortMetaData=p}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-selection-sort"]],decls:10,vars:8,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1,"Selection Sort"),s.qZA(),s._UZ(2,"div",1),s._UZ(3,"div",1),s._UZ(4,"div",1),s._UZ(5,"div",1),s._UZ(6,"div",1),s._UZ(7,"div",1),s._UZ(8,"div",1),s._UZ(9,"div",1)),2&e&&(s.xp6(2),s.Q6J("innerHtml",t.selectionSortMetaData.defination,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.explainImage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.properties,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.flowChart,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.workingProcedure,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.applications,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.advantage,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.selectionSortMetaData.disadvantage,s.oJD))},styles:[""]}),e})(),y=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-shell-sort"]],decls:2,vars:0,consts:[[1,"text-center"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1," Coming soon"),s.qZA())},styles:[""]}),e})();var b=o(4912);function S(e,t){if(1&e&&(s.TgZ(0,"div",5),s.TgZ(1,"p",6),s._uU(2),s.qZA(),s.qZA()),2&e){const e=s.oxw().$implicit;s.Q6J("routerLink",e.route),s.xp6(2),s.Oqu(e.name)}}function x(e,t){if(1&e&&(s.ynx(0),s.YNc(1,S,3,2,"div",4),s.BQk()),2&e){const e=t.index;s.xp6(1),s.Q6J("ngIf",0!=e)}}const D=[{path:"",component:(()=>{class e{constructor(){this.sortingMetaData=h,this.sortingType=b.wr}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=s.Xpm({type:e,selectors:[["app-sorting-algorithm"]],decls:8,vars:5,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","align-items-center","horizontal-scroll"],[4,"ngFor","ngForOf"],["class","box p-lg-2 p-1 px-lg-3 px-2 tab me-lg-4 me-3",3,"routerLink",4,"ngIf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","tab","me-lg-4","me-3",3,"routerLink"],[1,"m-0"]],template:function(e,t){1&e&&(s.TgZ(0,"h1",0),s._uU(1,"Sorting Algorithms"),s.qZA(),s._UZ(2,"div",1),s._UZ(3,"div",1),s.TgZ(4,"div",2),s.YNc(5,x,2,1,"ng-container",3),s.qZA(),s._UZ(6,"div",1),s._UZ(7,"div",1)),2&e&&(s.xp6(2),s.Q6J("innerHtml",t.sortingMetaData.defination,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.sortingMetaData.properties,s.oJD),s.xp6(2),s.Q6J("ngForOf",t.sortingType),s.xp6(1),s.Q6J("innerHtml",t.sortingMetaData.classifications,s.oJD),s.xp6(1),s.Q6J("innerHtml",t.sortingMetaData.example,s.oJD))},directives:[r.sg,r.O5,n.rH],styles:[""]}),e})()},{path:"bubble-sort",component:i},{path:"selection-sort",component:v},{path:"insertion-sort",component:g},{path:"merge-sort",component:u},{path:"quick-sort",component:f},{path:"counting-sort",component:l},{path:"radix-sort",component:w},{path:"bucket-sort",component:a},{path:"shell-sort",component:y}];let J=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=s.oAB({type:e}),e.\u0275inj=s.cJS({imports:[[n.Bz.forChild(D)],n.Bz]}),e})(),T=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=s.oAB({type:e}),e.\u0275inj=s.cJS({imports:[[r.ez,J]]}),e})()}}]);