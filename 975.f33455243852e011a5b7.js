(self.webpackChunkdsa_visualisation=self.webpackChunkdsa_visualisation||[]).push([[975],{4975:(e,t,i)=>{"use strict";i.r(t),i.d(t,{AlgorithmsModule:()=>u});var n=i(8583),o=i(2389),a=i(1077);const r={defination:a.W.setHeader("An algorithm is a procedure used for solving a problem or performing a computation. Algorithms act as an exact list of instructions that conduct specified actions step by step in either hardware- or software-based routines"),characteristics:a.W.setListwithTitleHtml("What are the Characteristics of an Algorithm",["<b>Clear and Unambiguous</b>: The algorithm should be clear and unambiguous. Each of its steps should be clear in all aspects and must lead to only one meaning","<b>Well-Defined Inputs</b>: If an algorithm says to take inputs, it should be well-defined inputs","<b>Well-Defined Outputs</b>:The algorithm must clearly define what output will be yielded and it should be well-defined as well","<b>Finite-ness</b>:The algorithm must be finite, i.e. it should terminate after a finite time","<b>Feasible</b>: The algorithm must be simple, generic, and practical, such that it can be executed with the available resources. It must not contain some future technology or anything","<b>Language Independent</b>: The Algorithm designed must be language-independent, i.e. it must be just plain instructions that can be implemented in any language, and yet the output will be the same, as expected"]),properties:a.W.setListwithTitleHtml("Properties of Algorithm",["It should terminate after a finite time","It should produce at least one output","It should take zero or more input","It should be deterministic means giving the same output for the same input case","Every step in the algorithm must be effective i.e. every step should do some work"]),types:a.W.setListwithTitleHtml("Types of Algorithm",["<b>Brute Force Algorithm</b>:It is the simplest approach for a problem. A brute force algorithm is the first approach that comes to finding when we see a problem","<b>Recursive Algorithm</b>: A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again","<b>Sorting Algorithm</b>: Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner","<b>Searching Algorithm</b>: Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found","<b>Hashing Algorithm</b>:Hashing algorithms work similarly to the searching algorithm. But they contain an index with a key ID. In hashing, a key is assigned to specific data","<b>Divide and Conquer Algorithm</b>:This algorithm breaks a problem into sub-problems, solves a single sub-problem and merges the solutions together to get the final solution. It consists of the following three steps:<br>Divide<br>Solve<br>Combine","<b>Dynamic Programming Algorithm</b>: This algorithm uses the concept of using the already found solution to avoid repetitive calculation of the same part of the problem. It divides the problem into smaller overlapping subproblems and solves them","<b>Greedy Algorithm</b>:In this type of algorithm the solution is built part by part. The solution of the next part is built based on the immediate benefit of the next part. The one solution giving the most benefit will be chosen as the solution for the next part","<b>Backtracking Algorithm</b>:The backtracking algorithm basically builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point and build on the next solution and continue this process till we find the solution or all possible solutions are looked after","<b>Randomized Algorithm</b>:In the randomized algorithm we use a random number so it gives immediate benefit. The random number helps in deciding the expected outcome"]),others:a.W.setListwithTitleHtml("How to Design an Algorithm",["The problem that is to be solved by this algorithm i.e. clear problem definition","The constraints of the problem must be considered while solving the problem","The input to be taken to solve the problem","The output to be expected when the problem is solved","The solution to this problem, is within the given constraints"]),advantages:a.W.setListwithTitleHtml("Advantages",["It is easy to understand","An algorithm is a step-wise representation of a solution to a given problem","In Algorithm the problem is broken down into smaller pieces or steps hence, it is easier for the programmer to convert it into an actual program"]),disadvantages:a.W.setListwithTitleHtml("Disadvantages",["Writing an algorithm takes a long time so it is time-consuming","Understanding complex logic through algorithms can be very difficult","Branching and Looping statements are difficult to show in Algorithms"])};var s=i(4912),l=i(3018);function h(e,t){if(1&e&&(l.TgZ(0,"div",5),l.TgZ(1,"p",6),l._uU(2),l.qZA(),l.qZA()),2&e){const e=l.oxw().$implicit;l.Q6J("routerLink",e.route),l.xp6(2),l.Oqu(e.name)}}function d(e,t){if(1&e&&(l.ynx(0),l.YNc(1,h,3,2,"div",4),l.BQk()),2&e){const e=t.index;l.xp6(1),l.Q6J("ngIf",0!=e)}}const m=[{path:"",component:(()=>{class e{constructor(){this.algorithmMetaData=r,this.algorithms=s.yH}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=l.Xpm({type:e,selectors:[["app-algorithm"]],decls:11,vars:8,consts:[[1,"text-center"],[1,"mt-md-4","mt-3",3,"innerHtml"],[1,"mt-md-4","mt-3","d-flex","align-items-center","horizontal-scroll"],[4,"ngFor","ngForOf"],["class","box p-lg-2 p-1 px-lg-3 px-2 tab me-lg-4 me-3",3,"routerLink",4,"ngIf"],[1,"box","p-lg-2","p-1","px-lg-3","px-2","tab","me-lg-4","me-3",3,"routerLink"],[1,"m-0"]],template:function(e,t){1&e&&(l.TgZ(0,"h1",0),l._uU(1,"Algorithms"),l.qZA(),l._UZ(2,"div",1),l._UZ(3,"div",1),l._UZ(4,"div",1),l._UZ(5,"div",1),l.TgZ(6,"div",2),l.YNc(7,d,2,1,"ng-container",3),l.qZA(),l._UZ(8,"div",1),l._UZ(9,"div",1),l._UZ(10,"div",1)),2&e&&(l.xp6(2),l.Q6J("innerHtml",t.algorithmMetaData.defination,l.oJD),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.characteristics,l.oJD),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.properties,l.oJD),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.types,l.oJD),l.xp6(2),l.Q6J("ngForOf",t.algorithms),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.others,l.oJD),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.advantages,l.oJD),l.xp6(1),l.Q6J("innerHtml",t.algorithmMetaData.disadvantages,l.oJD))},directives:[n.sg,n.O5,o.rH],styles:[""]}),e})()},{path:"backtracking",loadChildren:()=>i.e(344).then(i.bind(i,2344)).then(e=>e.BacktrackingModule)},{path:"brute-force",loadChildren:()=>i.e(529).then(i.bind(i,1529)).then(e=>e.BruteForceModule)},{path:"divide-and-conquer",loadChildren:()=>i.e(625).then(i.bind(i,625)).then(e=>e.DivideAndConquerModule)},{path:"dynamic-programming",loadChildren:()=>i.e(75).then(i.bind(i,5075)).then(e=>e.DynamicProgrammingModule)},{path:"greedy",loadChildren:()=>i.e(478).then(i.bind(i,478)).then(e=>e.GreedyModule)},{path:"randomized",loadChildren:()=>i.e(412).then(i.bind(i,5412)).then(e=>e.RandomizedModule)},{path:"recursive",loadChildren:()=>i.e(992).then(i.bind(i,1992)).then(e=>e.RecursiveModule)},{path:"searching",loadChildren:()=>i.e(722).then(i.bind(i,3722)).then(e=>e.SearchingModule)},{path:"sorting",loadChildren:()=>i.e(76).then(i.bind(i,6076)).then(e=>e.SortingModule)}];let g=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=l.oAB({type:e}),e.\u0275inj=l.cJS({imports:[[o.Bz.forChild(m)],o.Bz]}),e})(),u=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=l.oAB({type:e}),e.\u0275inj=l.cJS({imports:[[n.ez,g]]}),e})()}}]);